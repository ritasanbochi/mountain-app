<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>登山向け山岳マップ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
  :root{
    --bg:#0b1220;
    --panel:#111a2e;
    --panel2:#0f172a;
    --text:#e5e7eb;
    --muted:#9ca3af;
    --border:rgba(255,255,255,.12);
    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  html,body{ margin:0; height:100%; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial; background:#0b1220; color:var(--text); }
  #container{ height:100%; display:flex; flex-direction:column; }
  #topbar{
    display:flex; gap:10px; align-items:center;
    padding:10px 12px; background:linear-gradient(180deg, #0f172a, #0b1220);
    border-bottom:1px solid var(--border);
    position:relative; z-index:5;
  }
  #control{
    display:flex; flex-wrap:wrap; gap:10px 14px; align-items:center;
    font-size:14px;
  }
  #control .group{
    padding:8px 10px; background:rgba(255,255,255,.04);
    border:1px solid var(--border); border-radius:10px;
  }
  #control b{ display:block; font-size:12px; color:var(--muted); margin-bottom:4px; }
  #control label{ margin-right:10px; cursor:pointer; }
  #control input[type="checkbox"]{ transform: translateY(1px); }
  #control select,#control input[type="range"]{
    accent-color:#60a5fa;
  }
  #status{
    margin-left:auto;
    min-width:260px;
    padding:8px 10px; border-radius:10px;
    border:1px solid var(--border);
    background:rgba(255,255,255,.04);
    font-size:12px; color:var(--muted);
    line-height:1.35;
    white-space:pre-line;
  }

  #map{ flex:1; }

  /* list panel (PC) */
  #listPanel{
    position:absolute; top:62px; left:12px; width:340px; max-height:70vh;
    background:rgba(17,26,46,.92);
    border:1px solid var(--border);
    border-radius:14px;
    box-shadow:var(--shadow);
    overflow:hidden;
    z-index:6;
    backdrop-filter: blur(8px);
  }
  #listHead{
    padding:10px 12px; display:flex; align-items:center; justify-content:space-between;
    border-bottom:1px solid var(--border);
    font-weight:700;
  }
  #listBody{
    padding:8px 10px;
    overflow:auto;
    max-height: calc(70vh - 44px);
  }
  .row{
    display:flex; gap:8px; align-items:center;
    padding:8px 8px;
    border-radius:10px;
    cursor:pointer;
  }
  .row:hover{ background:rgba(255,255,255,.06); }
  .badge{
    min-width:24px; text-align:center;
    font-weight:800; font-size:12px;
    padding:3px 6px; border-radius:999px;
    border:1px solid var(--border);
  }
  .badge.a{ background:#0a3; color:#eafff2; border-color:rgba(0,255,140,.28); }
  .badge.b{ background:#b90; color:#fff7e6; border-color:rgba(255,200,0,.28); }
  .badge.c{ background:#a00; color:#ffe7e7; border-color:rgba(255,80,80,.28); }
  .badge.x{ background:#334155; color:#e5e7eb; border-color:rgba(255,255,255,.12); } /* 未取得 */
  .mname{ flex:1; }
  .meta{ color:var(--muted); font-size:12px; }

  /* detail overlay */
  #detailOverlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,.55);
    display:none;
    z-index:10;
  }
  #detail{
    position:absolute;
    right:12px; top:72px;
    width:min(520px, calc(100vw - 24px));
    max-height: calc(100vh - 90px);
    overflow:auto;
    background:rgba(17,26,46,.97);
    border:1px solid var(--border);
    border-radius:14px;
    box-shadow:var(--shadow);
    backdrop-filter: blur(8px);
  }
  #detailHeader{
    padding:10px 12px;
    display:flex; align-items:center; justify-content:space-between;
    border-bottom:1px solid var(--border);
  }
  #detailTitle{ font-weight:800; }
  #detailClose{ cursor:pointer; border:1px solid var(--border); background:rgba(255,255,255,.06); color:var(--text); padding:6px 10px; border-radius:10px; }
  #detailBody{ padding:10px 12px; font-size:14px; }

  table{ width:100%; border-collapse:collapse; }
  th,td{ border-bottom:1px solid rgba(255,255,255,.08); padding:6px 6px; text-align:left; vertical-align:top; }
  th{ color:var(--muted); font-weight:700; font-size:12px; }
  .wx-current{ background:rgba(96,165,250,.10); }

  /* mobile bottom sheet list */
  @media (max-width: 860px){
    #listPanel{ left:0; right:0; top:auto; bottom:0; width:auto; max-height:60vh; border-radius:18px 18px 0 0; }
    #detail{ right:0; left:0; top:auto; bottom:0; width:auto; max-height:70vh; border-radius:18px 18px 0 0; }
  }
</style>
</head>
<body>
<div id="container">
  <div id="topbar">
    <div id="control">
      <div class="group">
        <b>日付</b>
        <select id="daySelect">
          <option value="0">今日</option>
          <option value="1">明日</option>
          <option value="2">明後日</option>
          <option value="3">3日後</option>
        </select>
      </div>

      <div class="group">
        <b>時間帯</b>
        <input id="timeSlider" type="range" min="0" max="5" value="0">
        <span id="timeLabel">06–08</span>
      </div>

      <div class="group">
        <b>山セット</b>
        <label><input type="checkbox" class="setChk" value="HYAKU" checked>百名山</label>
        <label><input type="checkbox" class="setChk" value="HANA_100" checked>花の百名山</label>
        <label><input type="checkbox" class="setChk" value="NIHON_200" checked>二百名山</label>
        <label><input type="checkbox" class="setChk" value="NIHON_300">三百名山</label>
      </div>

      <div class="group">
        <b>天気</b>
        <label><input type="checkbox" value="A" checked>A</label>
        <label><input type="checkbox" value="B" checked>B</label>
        <label><input type="checkbox" value="C" checked>C</label>
        <label style="margin-left:8px;"><input type="checkbox" id="goodOnly">良条件のみ（Aかつ上級除外）</label>
      </div>

      <div class="group">
        <b>難易度</b>
        <label><input type="checkbox" value="初級" checked>初級</label>
        <label><input type="checkbox" value="中級" checked>中級</label>
        <label><input type="checkbox" value="上級" checked>上級</label>
      </div>
    </div>

    <div id="status">初期化中…</div>
  </div>

  <div id="map"></div>

  <div id="listPanel">
    <div id="listHead">
      <span id="listTitle">山リスト</span>
      <span class="meta" id="listCount">-</span>
    </div>
    <div id="listBody"></div>
  </div>
</div>

<div id="detailOverlay">
  <div id="detail">
    <div id="detailHeader">
      <div id="detailTitle"></div>
      <button id="detailClose" type="button">閉じる</button>
    </div>
    <div id="detailBody"></div>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script type="module">
import mountains from "./mountains.js";
import mountainsExtra from "./mountains_extra.js";
import { generateWeatherScore } from "./weather.js";

/* ========= utilities ========= */
const timeSlots  = ["06:00","08:00","10:00","12:00","14:00","16:00"];
const timeLabels = ["06–08","08–10","10–12","12–14","14–16","16–18"];

const daySelect   = document.getElementById("daySelect");
const slider      = document.getElementById("timeSlider");
const timeLabelEl = document.getElementById("timeLabel");
const statusEl    = document.getElementById("status");

const listTitleEl = document.getElementById("listTitle");
const listCountEl = document.getElementById("listCount");
const listBodyEl  = document.getElementById("listBody");

const detailOverlay = document.getElementById("detailOverlay");
const detailTitle   = document.getElementById("detailTitle");
const detailBody    = document.getElementById("detailBody");
const detailClose   = document.getElementById("detailClose");

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, ch => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[ch]));
}
function normName(s){
  return String(s ?? "").trim().replace(/\s+/g,"").replace(/[（(].*?[）)]/g,"");
}
function setStatusHtml(lines){
  statusEl.textContent = Array.isArray(lines) ? lines.join("\n") : String(lines ?? "");
}
function isMobile(){
  return window.matchMedia("(max-width: 860px)").matches;
}
function dayLabel(d){
  return ["今日","明日","明後日","3日後"][d] ?? "";
}
function getSelectedTime(){
  return timeSlots[Number(slider.value) || 0];
}
function getDateKey(offsetDays){
  const base = new Date();
  base.setHours(0,0,0,0);
  base.setDate(base.getDate() + Number(offsetDays));
  const y = base.getFullYear();
  const m = String(base.getMonth()+1).padStart(2,"0");
  const d = String(base.getDate()).padStart(2,"0");
  return `${y}-${m}-${d}`;
}
function nearestTimeSlotIndexNow(){
  const now = new Date();
  const h = now.getHours() + now.getMinutes()/60;
  const slotHours = [6,8,10,12,14,16];
  let best = 0, bestDist = Infinity;
  for (let i=0;i<slotHours.length;i++){
    const dist = Math.abs(slotHours[i]-h);
    if (dist < bestDist){ bestDist = dist; best = i; }
  }
  return best;
}

/* ========= data merge (同名別座標でも消えない) ========= */
const byKey = new Map();          // key -> mountain
const byName = new Map();         // normalized name -> [mountain,...]

function normSetKey(s){
  if (s === "SAN_300") return "NIHON_300"; // 旧表記互換
  return s;
}
function makeKey(name, lat, lng){
  const base = normName(name);
  if (!base) return null;

  if (!byKey.has(base)) return base;

  const ex = byKey.get(base);
  const same =
    Number.isFinite(lat) && Number.isFinite(lng) &&
    Number.isFinite(ex.lat) && Number.isFinite(ex.lng) &&
    Math.abs(ex.lat - lat) < 1e-7 &&
    Math.abs(ex.lng - lng) < 1e-7;

  if (same) return base;

  if (Number.isFinite(lat) && Number.isFinite(lng)){
    return `${base}@${lat.toFixed(5)},${lng.toFixed(5)}`;
  }

  let i = 2;
  while (byKey.has(`${base}#${i}`)) i++;
  return `${base}#${i}`;
}
function upsertMountain(base){
  const sets = new Set((base._sets ?? []).map(normSetKey));
  const key = base.key ?? makeKey(base.name, base.lat, base.lng);
  if (!key) return null;

  if (!byKey.has(key)){
    const obj = {
      key,
      name: base.name,
      lat: base.lat ?? null,
      lng: base.lng ?? null,
      elev: base.elev ?? null,
      level: base.level ?? "中級",
      gpx: base.gpx ?? null,
      weather: base.weather ?? {},
      _sets: sets
    };
    byKey.set(key, obj);

    const nk = normName(base.name);
    if (!byName.has(nk)) byName.set(nk, []);
    byName.get(nk).push(obj);
  } else {
    const m = byKey.get(key);
    if (m.lat == null && base.lat != null) m.lat = base.lat;
    if (m.lng == null && base.lng != null) m.lng = base.lng;
    if (m.elev == null && base.elev != null) m.elev = base.elev;
    if (!m.level && base.level) m.level = base.level;
    if (!m.gpx && base.gpx) m.gpx = base.gpx;
    (base._sets ?? []).map(normSetKey).forEach(s => m._sets.add(s));
  }
  return byKey.get(key);
}

(mountains ?? []).forEach(m => upsertMountain({ ...m, _sets:["HYAKU"] }));
(mountainsExtra ?? []).forEach(m => upsertMountain(m));

/* ========= Leaflet ========= */
const mapObj = L.map("map", { zoomControl: true }).setView([36.2, 138.1], 6);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
  { opacity: 0.55, attribution:"地理院 陰影" }
).addTo(mapObj);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
  { opacity: 0.85, attribution:"地理院 地図" }
).addTo(mapObj);

const markerLayer = L.layerGroup().addTo(mapObj);

const icon = color => L.icon({
  iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
  shadowUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png",
  iconSize: [25,41],
  iconAnchor: [12,41]
});
const icons = { A:icon("green"), B:icon("yellow"), C:icon("red"), X:icon("grey") };
const scorePriority = { A:3, B:2, C:1 };

/* ========= markers ========= */
const markerEntries = []; // {m, marker, shown}
const markerByKey = new Map();

function addMarkerForMountain(m){
  const key = m.key;
  if (!key || markerByKey.has(key)) return;
  if (m.lat == null || m.lng == null) return;

  const marker = L.marker([m.lat, m.lng], { icon: icons.X }); // 未取得は灰色
  marker.on("click", () => {
    mapObj.setView([m.lat, m.lng], Math.max(mapObj.getZoom(), 10));
    openDetail(m, marker);
  });

  markerEntries.push({ m, marker, shown:false });
  markerByKey.set(key, marker);
}

/* ========= filters ========= */
function getState(){
  const day = Number(daySelect.value);
  const time = getSelectedTime();
  const dateKey = getDateKey(day);
  const goodOnly = document.getElementById("goodOnly").checked;

  const scores = [...document.querySelectorAll(
    'input[value="A"]:checked,input[value="B"]:checked,input[value="C"]:checked'
  )].map(e => e.value);

  const levels = [...document.querySelectorAll(
    'input[value="初級"]:checked,input[value="中級"]:checked,input[value="上級"]:checked'
  )].map(e => e.value);

  const sets = [...document.querySelectorAll(".setChk:checked")].map(e => e.value);

  return { day, time, dateKey, goodOnly, scores, levels, sets };
}
function mountainInSelectedSets(m, selectedSets){
  if (!selectedSets?.length) return true;
  for (const s of selectedSets){
    if (m._sets?.has(s)) return true;
  }
  return false;
}

/* ========= detail view ========= */
function fmtNum(n, digits=1){
  const v = Number(n);
  return Number.isFinite(v) ? v.toFixed(digits) : "-";
}
function getDetail(m, dateKey, time){
  const d = m.weather?.__detail?.[dateKey]?.[time];
  if (!d) return null;
  return d;
}
function detailHtml(m, selectedTime){
  const day = Number(daySelect.value);
  const dateKey = getDateKey(day);

  const rows = timeSlots.map((t, idx) => {
    const s = m.weather?.[dateKey]?.[t] ?? "-";
    const d = getDetail(m, dateKey, t);
    const cls = (t === selectedTime) ? "wx-current" : "";
    return `
      <tr class="${cls}">
        <td>${timeLabels[idx]}</td>
        <td><b>${s ?? "-"}</b></td>
        <td>${d ? `
          降水 ${fmtNum(d.precip)}mm / 風 ${fmtNum(d.wind)}m/s / 突風 ${fmtNum(d.gust)}m/s / 気温 ${fmtNum(d.temp)}℃
        ` : "-"}</td>
      </tr>`;
  }).join("");

  const sets = [...(m._sets ?? [])].join(" / ");

  return `
    <div class="meta" style="margin-bottom:10px;">
      セット: ${escapeHtml(sets)}<br>
      座標: ${fmtNum(m.lat,5)}, ${fmtNum(m.lng,5)} / 標高: ${m.elev ?? "-"}m / 難易度: ${escapeHtml(m.level)}
    </div>
    <table>
      <thead><tr><th style="width:22%;">時間帯</th><th style="width:12%;">スコア</th><th>詳細</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}
let currentDetail = null;
function openDetail(m, marker){
  currentDetail = { mountain:m, marker };
  detailTitle.textContent = m.name;
  detailBody.innerHTML = detailHtml(m, getSelectedTime());
  detailOverlay.style.display = "block";
}
function closeDetail(){
  currentDetail = null;
  detailOverlay.style.display = "none";
}
detailClose.addEventListener("click", closeDetail);
detailOverlay.addEventListener("click", (e) => {
  if (e.target === detailOverlay) closeDetail();
});

/* ========= list ========= */
function scoreBadgeClass(score){
  if (score === "A") return "a";
  if (score === "B") return "b";
  if (score === "C") return "c";
  return "x";
}
function getBestTime(weather, dateKey){
  if (!weather?.[dateKey]) return null;
  let best = null;
  for (let i=0;i<timeSlots.length;i++){
    const t = timeSlots[i];
    const s = weather[dateKey]?.[t];
    if (!s) continue;
    const p = scorePriority[s] || 0;
    if (!best || p > best.p){ best = { t, s, p, idx:i }; }
  }
  return best;
}
function drawList(items, day){
  listTitleEl.textContent = `${dayLabel(day)} の山`;
  listCountEl.textContent = `${items.length}件`;

  listBodyEl.innerHTML = items.map(it => {
    const badge = it.badge;
    const score = it.score;
    const meta = it.meta;
    return `
      <div class="row" data-key="${escapeHtml(it.m.key)}">
        <span class="badge ${badge}">${escapeHtml(score)}</span>
        <div class="mname">${escapeHtml(it.m.name)}</div>
        <div class="meta">${escapeHtml(meta)}</div>
      </div>`;
  }).join("");

  [...listBodyEl.querySelectorAll(".row")].forEach(row => {
    row.addEventListener("click", () => {
      const k = row.getAttribute("data-key");
      const entry = markerEntries.find(e => e.m.key === k);
      if (!entry) return;
      mapObj.setView([entry.m.lat, entry.m.lng], Math.max(mapObj.getZoom(), 10));
      openDetail(entry.m, entry.marker);
    });
  });
}

/* ========= main update ========= */
function updateView(){
  const { day, time, dateKey, goodOnly, scores, levels, sets } = getState();
  const items = [];

  for (const entry of markerEntries){
    const m = entry.m;
    const marker = entry.marker;

    // 未取得は "C扱い" で表示だけ出し、色は灰色で区別する
    const rawScore = m.weather?.[dateKey]?.[time];
    const score = rawScore ?? "C";

    const pass =
      scores.includes(score) &&
      levels.includes(m.level) &&
      mountainInSelectedSets(m, sets) &&
      !(goodOnly && (score !== "A" || m.level === "上級"));

    if (pass){
      if (!entry.shown){
        marker.addTo(markerLayer);
        entry.shown = true;
      }
      marker.setIcon(rawScore ? icons[score] : icons.X);

      const best = getBestTime(m.weather, dateKey);
      const meta = best ? `おすすめ:${timeLabels[best.idx]} ${best.s}` : (rawScore ? "" : "天気取得中…");
      items.push({ m, score:(rawScore ?? "…"), badge: scoreBadgeClass(rawScore), meta });
    } else {
      if (entry.shown){
        markerLayer.removeLayer(marker);
        entry.shown = false;
      }
      if (currentDetail?.mountain === m) closeDetail();
    }
  }

  drawList(items, day);

  if (currentDetail?.mountain){
    detailTitle.textContent = currentDetail.mountain.name;
    detailBody.innerHTML = detailHtml(currentDetail.mountain, time);
  }

  setTimeout(() => mapObj.invalidateSize(), 60);
}

/* ========= weather prefetch (自動で進む/順次反映) ========= */
async function runWithConcurrency(taskFns, concurrency, onProgress){
  let i = 0;
  let done = 0;
  const total = taskFns.length;

  const workers = Array.from({ length: Math.max(1, concurrency) }, async () => {
    while (true){
      const my = i++;
      if (my >= total) break;
      await taskFns[my]();
      done++;
      onProgress?.(done, total);
    }
  });

  await Promise.all(workers);
}

/* init */
async function init(){
  // 時間帯ラベル更新
  timeLabelEl.textContent = timeLabels[Number(slider.value) || 0];

  if (Number(daySelect.value) === 0) slider.value = String(nearestTimeSlotIndexNow());
  timeLabelEl.textContent = timeLabels[Number(slider.value) || 0];

  const all = [...byKey.values()];
  const geoOK = all.filter(m => Number.isFinite(m.lat) && Number.isFinite(m.lng));

  setStatusHtml([
    `固定データ統合: 合計${all.length}件 / 座標あり${geoOK.length}件`,
    `天気は localStorage キャッシュ有（weather.js）`,
    `初回ロードの429対策: 同時2本で取得（順次反映）`
  ]);

  for (const m of geoOK) addMarkerForMountain(m);
  updateView(); // 先に出す（未取得は灰色）

  // 天気取得タスク（既にm.weatherがあるものはスキップ）
  const tasks = geoOK.map(m => async () => {
    if (m.weather && Object.keys(m.weather).length) return;
    m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
  });

  let last = 0;
  await runWithConcurrency(tasks, 2, (done, total) => {
    // 進捗を間引いて更新
    if (done - last >= 10 || done === total){
      last = done;
      updateView();
      setStatusHtml([
        `固定データ統合: 合計${all.length}件 / 座標あり${geoOK.length}件`,
        `天気取得: ${done}/${total}（同時2本 / 自動で順次反映）`,
        `※三百名山はデフォルトOFF（重い場合はOFFのままでOK）`
      ]);
    }
  });

  updateView();

  document.querySelectorAll("#control input,#control select").forEach(e => {
    if (e === daySelect) return;
    e.addEventListener("change", () => updateView());
  });
  daySelect.addEventListener("change", () => {
    // 今日に戻したら時間帯を「現在に近い枠」へ戻す（既存仕様の踏襲）
    if (Number(daySelect.value) === 0) slider.value = String(nearestTimeSlotIndexNow());
    timeLabelEl.textContent = timeLabels[Number(slider.value) || 0];
    updateView();
  });

  slider.addEventListener("input", () => {
    timeLabelEl.textContent = timeLabels[Number(slider.value) || 0];
    updateView();
  });

  window.addEventListener("resize", () => mapObj.invalidateSize());
}

init().catch(e => {
  console.error(e);
  setStatusHtml([`初期化エラー: ${String(e?.message || e)}`]);
});
</script>
</body>
</html>
