<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>登山向け山岳マップ</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>

  <style>
    :root{
      --panel-bg:#f3f3f3;
      --card:#fff;
      --line:#ddd;
      --muted:#666;
      --chip:#eef2ff;
      --chip-text:#2b3a67;
    }
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; }
    #control {
      padding:10px;
      background:var(--panel-bg);
      font-size:14px;
      border-bottom:1px solid var(--line);
    }
    #container { display:flex; }
    #list {
      width: 320px;
      max-height: calc(100vh - 64px);
      overflow-y: auto;
      background: var(--card);
      border-right: 1px solid var(--line);
      padding: 8px;
      font-size: 13px;
    }
    #map { flex:1; height: calc(100vh - 64px); }

    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row + .row { margin-top:8px; }

    .seg { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .seg b { margin-right:6px; }

    /* ✅ チェックが左に寄る崩れを防ぐ（テキスト左、チェック右を固定） */
    .cb {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:4px 8px;
      background:#fff;
      border:1px solid var(--line);
      border-radius:8px;
      min-width: 92px;
      user-select:none;
    }
    .cb span { color:#111; }
    .cb input { margin:0; }

    .chip {
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      background:var(--chip);
      color:var(--chip-text);
      border:1px solid #cbd5ff;
      font-size:12px;
      margin-left:8px;
    }
    #setStatus{
      margin-top:8px;
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
      max-width: 1200px;
    }

    .list-item{
      border-bottom: 1px solid var(--line);
      padding: 8px 6px;
      cursor: pointer;
    }
    .list-item:hover{ background:#f7fbff; }
    .nameLine{ display:flex; justify-content:space-between; gap:8px; }
    .nameLine b{ font-size:14px; }
    .metaLine{ margin-top:4px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap; }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      font-size:12px;
      color:#111;
    }
    .badge small{ color:var(--muted); font-size:11px; }

    .popup h3{ margin:0 0 6px 0; font-size:16px; }
    .popup .p{ margin:4px 0; font-size:13px; }
    .wxgrid{
      margin-top:6px;
      border-top:1px solid #eee;
      padding-top:6px;
      display:grid;
      grid-template-columns: 1fr;
      gap:6px;
      font-size:12px;
    }
    .wxrow{ display:flex; justify-content:space-between; gap:10px; }
    .wxrow .k{ color:var(--muted); }
    .scoreA{ color:#1b7f2a; font-weight:700; }
    .scoreB{ color:#a77700; font-weight:700; }
    .scoreC{ color:#b42318; font-weight:700; }

    /* スマホ */
    @media (max-width: 780px){
      #container{ flex-direction:column; }
      #list{ width:auto; max-height: 38vh; border-right:none; border-bottom:1px solid var(--line); }
      #map{ height: calc(100vh - 64px - 38vh); }
    }
  /* NowLoading overlay（取得中は画面操作をブロック） */
#loadingOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  pointer-events: auto; /* クリックを吸収して操作不能化 */
}
#loadingOverlay .box{
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 14px;
  padding: 14px 16px;
  min-width: 220px;
  max-width: 86vw;
  font-size: 14px;
  line-height: 1.4;
  box-shadow: 0 10px 28px rgba(0,0,0,0.18);
  text-align: center;
}
#loadingOverlay .box b{ display:block; margin-bottom:6px; font-size:15px; }
#loadingOverlay .box .sub{ color:#666; font-size:12px; }
  

#mountainOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  display: none;
  z-index: 9998;
  pointer-events: auto;
}
#mountainOverlay .panel{
  position: absolute;
  inset: 10px;
  background: #fff;
  border-radius: 16px;
  padding: 12px 12px 16px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
#mountainOverlayClose{
  position: sticky;
  top: 0;
  float: right;
  margin-left: 8px;
  padding: 8px 10px;
  border: 1px solid #ddd;
  background: #fff;
  border-radius: 10px;
  cursor: pointer;
}
#mountainOverlayBody h2{ margin: 2px 0 6px; font-size: 18px; }
#mountainOverlayBody .sub{ color:#666; font-size: 12px; margin-bottom: 8px; }
.wxTable{
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
.wxTable th, .wxTable td{
  border: 1px solid #eee;
  padding: 6px 6px;
  text-align: center;
  vertical-align: middle;
  white-space: nowrap;
}
.wxTable th.sticky{
  position: sticky;
  left: 0;
  background: #fff;
  text-align: left;
}

</style>
</head>

<body>
  <div id="control">
    <div class="row">
      <div class="seg">
        <b>日付</b>
        <select id="day">
          <option value="0">今日</option>
          <option value="1">1日後</option>
          <option value="2">2日後</option>
          <option value="3">3日後</option>
        </select>

        <b>時間帯</b>
        <input type="range" id="timeSlider" min="0" max="5" step="1" value="0">
        <span id="timeLabel">06–08</span>
      </div>

      <div class="seg">
        <b>天気</b>
        <label class="cb"><span>A</span><input type="checkbox" value="A" checked></label>
        <label class="cb"><span>B</span><input type="checkbox" value="B" checked></label>
        <label class="cb"><span>C</span><input type="checkbox" value="C" checked></label>

        <b>難易度</b>
        <label class="cb"><span>初級</span><input type="checkbox" value="初級" checked></label>
        <label class="cb"><span>中級</span><input type="checkbox" value="中級" checked></label>
        <label class="cb"><span>上級</span><input type="checkbox" value="上級" checked></label>
      </div>

      <div class="seg">
        <label class="cb" style="min-width:160px;">
          <span>登れる山だけ</span><input type="checkbox" id="goodOnly">
        </label>
      </div>

      <div class="seg">
        <b>表示セット</b>
        <label class="cb" style="min-width:170px;"><span>百名山</span><input type="checkbox" id="setHYAKU" checked></label>
        <label class="cb" style="min-width:170px;"><span>花の百名山</span><input type="checkbox" id="setHANA"></label>
        <label class="cb" style="min-width:170px;"><span>二百名山</span><input type="checkbox" id="setN200"></label>
        <span class="chip" id="countChip">読込中...</span>
      </div>
    </div>

    <div id="setStatus"></div>
  </div>

  <div id="container">
    <div id="list"></div>
    <div id="map"></div>
  </div>


<!-- Mountain detail overlay (full screen) -->
<div id="mountainOverlay" aria-hidden="true">
  <div class="panel">
    <button id="mountainOverlayClose" type="button">閉じる</button>
    <div id="mountainOverlayBody"></div>
  </div>
</div>

<div id="loadingOverlay" aria-hidden="true">
  <div class="box">
    <b>NowLoading...</b>
    <div class="sub" id="loadingSub">天気を取得中です</div>
  </div>
</div>


  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script type="module">
    import mountains from "./mountains.js";
    import mountainsExtra from "./mountains_extra.js";
    import { generateWeatherScore } from "./weather.js";

    /* ========= time UI ========= */
    const timeSlots  = ["06:00","08:00","10:00","12:00","14:00","16:00"];
    const timeLabels = ["06–08","08–10","10–12","12–14","14–16","16–18"];
    const slider = document.getElementById("timeSlider");
    const timeLabel = document.getElementById("timeLabel");
    const daySelect = document.getElementById("day");

    function pad2(n){ return String(n).padStart(2,"0"); }
    const WDS = ["日","月","火","水","木","金","土"];
    function getDateObj(offset){
      const d = new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate()+offset);
      return d;
    }
    function formatLocalYMD(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function getDateKey(offset){ return formatLocalYMD(getDateObj(offset)); }
    function dayLabel(offset){
      const d = getDateObj(offset);
      const mm = pad2(d.getMonth()+1), dd = pad2(d.getDate()), wd = WDS[d.getDay()];
      const rel = offset === 0 ? "今日" : `${offset}日後`;
      return `${mm}/${dd}(${wd}) ${rel}`;
    }
    function initDaySelectLabels(){
      [...daySelect.options].forEach(opt => opt.textContent = dayLabel(Number(opt.value)));
    }
    initDaySelectLabels();

    function nearestTimeSlotIndexNow(){
      const now = new Date();
      const nowMin = now.getHours()*60 + now.getMinutes();
      const starts = timeSlots.map(s => Number(s.slice(0,2))*60);
      let best = 0, bestDiff = Infinity;
      starts.forEach((m, i) => {
        const diff = Math.abs(nowMin - m);
        if (diff < bestDiff){ bestDiff = diff; best = i; }
      });
      if (nowMin < starts[0]) return 0;
      if (nowMin > starts[starts.length-1]) return starts.length-1;
      return best;
    }

    function getSelectedTimeSlot(){ return timeSlots[Number(slider.value)]; }
    function getDateOffset(){ return Number(daySelect.value); }

    slider.addEventListener("input", () => {
      timeLabel.textContent = timeLabels[Number(slider.value)];
      draw();
    });

    daySelect.addEventListener("change", () => {
      if (Number(daySelect.value) === 0){
        slider.value = String(nearestTimeSlotIndexNow());
        timeLabel.textContent = timeLabels[Number(slider.value)];
      }
      draw();
    });

    /* ========= filters ========= */
    const scoreChecks = () => [...document.querySelectorAll('input[type="checkbox"][value="A"],input[type="checkbox"][value="B"],input[type="checkbox"][value="C"]')]
      .filter(x=>x.checked).map(x=>x.value);

    const levelChecks = () => [...document.querySelectorAll('input[type="checkbox"][value="初級"],input[type="checkbox"][value="中級"],input[type="checkbox"][value="上級"]')]
      .filter(x=>x.checked).map(x=>x.value);

    const goodOnly = document.getElementById("goodOnly");

    const setHYAKU = document.getElementById("setHYAKU");
    const setHANA  = document.getElementById("setHANA");
    const setN200  = document.getElementById("setN200");

    const setStatus = document.getElementById("setStatus");
    const countChip = document.getElementById("countChip");

    function escapeHtml(s){
      return String(s ?? "").replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    function setStatusHtml(lines){
      const safe = (lines || []).filter(Boolean).slice(0, 14).map(escapeHtml);
      setStatus.innerHTML = safe.join("<br>");
    }

    function normName(s){
      return String(s||"")
        .replace(/\s+/g,"")
        .replace(/[‐-–—−]/g,"-")
        .trim();
    }

    /* ========= merge mountains =========
       - mountains.js(百名山) は常に HYAKU セット扱い
       - mountains_extra.js は _sets を尊重
       - 同名は統合して _sets を union
    */
    function withDefaultSets(m){
      const sets = Array.isArray(m._sets) ? m._sets.slice() : [];
      // 百名山側はHYAKUを付与
      if (!sets.includes("HYAKU") && m.__from === "BASE") sets.push("HYAKU");
      return { ...m, _sets: sets };
    }

    function mergeAll(base, extra){
      const map = new Map();

      base.forEach(m => {
        const key = normName(m.name);
        const mm = withDefaultSets({ ...m, __from:"BASE" });
        map.set(key, mm);
      });

      (extra || []).forEach(m => {
        const key = normName(m.name);
        if (!key) return;
        const ex = withDefaultSets({ ...m, __from:"EXTRA" });
        const cur = map.get(key);
        if (!cur){
          map.set(key, ex);
        }else{
          // 既存優先で座標/標高などは欠けを補完、_sets は union
          const sets = Array.from(new Set([...(cur._sets||[]), ...(ex._sets||[])]));
          map.set(key, {
            ...cur,
            lat:  (cur.lat  ?? ex.lat  ?? null),
            lng:  (cur.lng  ?? ex.lng  ?? null),
            elev: (cur.elev ?? ex.elev ?? null),
            level:(cur.level?? ex.level?? "中級"),
            gpx:  (cur.gpx  ?? ex.gpx  ?? null),
            _sets: sets
          });
        }
      });

      return [...map.values()];
    }

    const ALL = mergeAll(mountains, mountainsExtra);

    /* ========= map ========= */
    const mapObj = L.map("map").setView([36.5, 138.0], 5);

    // 地理院 標準地図 + 陰影（元の方針維持）
    L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
      { attribution:"地理院タイル", opacity:0.85 }
    ).addTo(mapObj);

    L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
      { attribution:"地理院 陰影", opacity:0.45 }
    ).addTo(mapObj);

    const markerLayer = L.layerGroup().addTo(mapObj);

    /* ========= marker icons =========
       ✅ “チープ”対策：Leafletカラー標準マーカーに戻す（見た目が安定）
    */
    function icon(color){
      return L.icon({
        iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
        shadowUrl: "https://unpkg.com/leaflet/dist/images/marker-shadow.png",
        iconSize:[25,41],
        iconAnchor:[12,41],
        popupAnchor:[1,-34],
        shadowSize:[41,41],
      });
    }
    const ICONS = {
      A: icon("green"),
      B: icon("yellow"),
      C: icon("red"),
      N: icon("grey"),
    };

    /* ========= weather cache in memory ========= */
    // mountainKey -> weatherObject
    const WX = new Map();
const WX_META = { ok:0, ng:0, cacheHit:0, lastErr:"" };

// 失敗を null で固定キャッシュしない（=以後取りに行かなくなる事故防止）
// ただし無限リトライで429を誘発しないよう、山ごとに短時間だけ再試行を抑制する
const WX_FAIL_NEXT = new Map(); // key -> nextAt(ms)

async function ensureWeatherFor(m){
  const key = normName(m.name);

  // 成功キャッシュがあれば返す
  const cached = WX.get(key);
  if (cached) return cached;

  // 直近失敗後のクールダウン中はスキップ
  const nextAt = WX_FAIL_NEXT.get(key) || 0;
  if (Date.now() < nextAt) return null;

  try{
    const w = await generateWeatherScore(m.name, m.lat, m.lng, m.level || "中級", m.elev ?? null);
    if (w){
      WX.set(key, w);
      WX_META.ok++;
      return w;
    }
    return null;
  }catch(e){
    WX_META.ng++;
    WX_META.lastErr = String(e?.message || e);
    // 30秒クールダウン（429/ネット不安定で連打しない）
    WX_FAIL_NEXT.set(key, Date.now() + 30_000);
    return null;
  }
}    

    function scoreAt(m, dateKey, timeSlot){
      const w = WX.get(normName(m.name));
      if (!w) return null;
      return w?.[dateKey]?.[timeSlot] ?? null;
    }

    function detailAt(m, dateKey, timeSlot){
      const w = WX.get(normName(m.name));
      if (!w) return null;
      // ✅ “降水/風/突風/気温が表示されない”の主因：__detail を読む
      return w?.__detail?.[dateKey]?.[timeSlot] ?? null;
    }

    /* ========= set filter ========= */
    function selectedSets(){
      const s = [];
      if (setHYAKU.checked) s.push("HYAKU");
      if (setHANA.checked)  s.push("HANA_100");
      if (setN200.checked)  s.push("NIHON_200");
      return s;
    }
    function inSelectedSets(m){
      const want = selectedSets();
      const has = Array.isArray(m._sets) ? m._sets : [];
      return want.some(k => has.includes(k));
    }

    /* ========= list & popup ========= */
    function scoreClass(s){
      if (s==="A") return "scoreA";
      if (s==="B") return "scoreB";
      if (s==="C") return "scoreC";
      return "";
    }

    function overlayHtml(m){
      const sets = (m._sets||[]).map(x=>{
        if (x==="HYAKU") return "百";
        if (x==="HANA_100") return "花";
        if (x==="NIHON_200") return "200";
        return x;
      }).join(" / ");

      const dayOffsets = [0,1,2,3]; // 今日〜3日後
      const dayKeys = dayOffsets.map(d=>getDateKey(d));
      const dayHeads = dayOffsets.map(d=>dayLabel(d));

      // ヘッダ行（左端: 時間帯 / 列: 日付）
      const head = `<tr><th class="sticky">時間</th>${dayHeads.map(h=>`<th>${escapeHtml(h)}</th>`).join("")}</tr>`;

      const body = timeLabels.map(ts=>{
        const cells = dayKeys.map(dk=>{
          const s = scoreAt(m, dk, ts) || "—";
          return `<td><span class="${scoreClass(s)}">${escapeHtml(String(s))}</span></td>`;
        }).join("");
        return `<tr><th class="sticky">${escapeHtml(ts)}</th>${cells}</tr>`;
      }).join("");

      // いま選択中の詳細
      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();
      const sNow = scoreAt(m, dateKey, timeSlot) || "—";
      const dNow = detailAt(m, dateKey, timeSlot);

      return `
        <div class="popup">
          <h2>${escapeHtml(m.name)}</h2>
          <div class="sub">標高: ${m.elev ?? "?"}m / 難易度: ${escapeHtml(m.level ?? "中級")} / セット: ${escapeHtml(sets || "-")}</div>

          <div class="p">現在選択: ${escapeHtml(dayLabel(getDateOffset()))} ${escapeHtml(timeSlot)}　天気スコア: <span class="${scoreClass(sNow)}">${escapeHtml(String(sNow))}</span></div>
          <div class="wxgrid">
            <div class="wxrow"><div class="k">降水</div><div>${dNow?.precip ?? "—"} mm</div></div>
            <div class="wxrow"><div class="k">風</div><div>${dNow?.wind ?? "—"} m/s</div></div>
            <div class="wxrow"><div class="k">突風</div><div>${dNow?.gust ?? "—"} m/s</div></div>
            <div class="wxrow"><div class="k">気温</div><div>${dNow?.temp ?? "—"} ℃</div></div>
          </div>

          <div class="p" style="margin-top:10px;">天気スコア表（今日〜3日後 / 時間帯ごと）</div>
          <table class="wxTable">${head}${body}</table>
        </div>
      `;
    }

    function openMountainOverlay(m){
      const el = document.getElementById("mountainOverlay");
      const body = document.getElementById("mountainOverlayBody");
      if (!el || !body) return;
      body.innerHTML = overlayHtml(m);
      el.style.display = "block";
      el.setAttribute("aria-hidden","false");
    }
    function closeMountainOverlay(){
      const el = document.getElementById("mountainOverlay");
      if (!el) return;
      el.style.display = "none";
      el.setAttribute("aria-hidden","true");
    }

