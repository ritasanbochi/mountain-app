<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ç™»å±±å‘ã‘å±±å²³ãƒãƒƒãƒ—</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <style>
    :root {
      --panel-bg: #f3f3f3;
      --card: #fff;
      --line: #ddd;
      --muted: #666;
      --chip: #eef2ff;
      --chip-text: #2b3a67;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
    }

    #control {
      padding: 10px;
      background: var(--panel-bg);
      font-size: 14px;
      border-bottom: 1px solid var(--line);
    }

    #container {
      display: flex;
    }

    #list {
      width: 320px;
      max-height: calc(100vh - 64px);
      overflow-y: auto;
      background: var(--card);
      border-right: 1px solid var(--line);
      padding: 8px;
      font-size: 13px;
    }

    #map {
      flex: 1;
      height: calc(100vh - 64px);
    }

    .row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .row+.row {
      margin-top: 8px;
    }

    .seg {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .seg b {
      margin-right: 6px;
    }

    /* âœ… ãƒã‚§ãƒƒã‚¯ãŒå·¦ã«å¯„ã‚‹å´©ã‚Œã‚’é˜²ãï¼ˆãƒ†ã‚­ã‚¹ãƒˆå·¦ã€ãƒã‚§ãƒƒã‚¯å³ã‚’å›ºå®šï¼‰ */
    .cb {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 4px 8px;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 8px;
      min-width: 92px;
      user-select: none;
    }

    .cb span {
      color: #111;
    }

    .cb input {
      margin: 0;
    }

    .chip {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      background: var(--chip);
      color: var(--chip-text);
      border: 1px solid #cbd5ff;
      font-size: 12px;
      margin-left: 8px;
    }

    #setStatus {
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
      max-width: 1200px;
    }

    .list-item {
      border-bottom: 1px solid var(--line);
      padding: 8px 6px;
      cursor: pointer;
    }

    .list-item:hover {
      background: #f7fbff;
    }

    .nameLine {
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .nameLine b {
      font-size: 14px;
    }

    .metaLine {
      margin-top: 4px;
      color: var(--muted);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #fff;
      font-size: 12px;
      color: #111;
    }

    .badge small {
      color: var(--muted);
      font-size: 11px;
    }

    .popup h3 {
      margin: 0 0 6px 0;
      font-size: 16px;
    }

    .popup .p {
      margin: 4px 0;
      font-size: 13px;
    }

    .wxgrid {
      margin-top: 6px;
      border-top: 1px solid #eee;
      padding-top: 6px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      font-size: 12px;
    }

    .wxrow {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .wxrow .k {
      color: var(--muted);
    }

    .scoreA {
      color: #1b7f2a;
      font-weight: 700;
    }

    .scoreB {
      color: #a77700;
      font-weight: 700;
    }

    .scoreC {
      color: #b42318;
      font-weight: 700;
    }

    /* ã‚¹ãƒãƒ› */
    @media (max-width: 780px) {
      #container {
        flex-direction: column;
      }

      #list {
        width: auto;
        max-height: 38vh;
        border-right: none;
        border-bottom: 1px solid var(--line);
      }

      #map {
        height: calc(100vh - 64px - 38vh);
      }
    }
  </style>
</head>

<body>
  <div id="control">
    <div class="row">
      <div class="seg">
        <b>æ—¥ä»˜</b>
        <select id="day">
          <option value="0">ä»Šæ—¥</option>
          <option value="1">1æ—¥å¾Œ</option>
          <option value="2">2æ—¥å¾Œ</option>
          <option value="3">3æ—¥å¾Œ</option>
        </select>

        <b>æ™‚é–“å¸¯</b>
        <input type="range" id="timeSlider" min="0" max="5" step="1" value="0">
        <span id="timeLabel">06â€“08</span>
      </div>

      <div class="seg">
        <b>å¤©æ°—</b>
        <label class="cb"><span>A</span><input type="checkbox" value="A" checked></label>
        <label class="cb"><span>B</span><input type="checkbox" value="B" checked></label>
        <label class="cb"><span>C</span><input type="checkbox" value="C" checked></label>

        <b>é›£æ˜“åº¦</b>
        <label class="cb"><span>åˆç´š</span><input type="checkbox" value="åˆç´š" checked></label>
        <label class="cb"><span>ä¸­ç´š</span><input type="checkbox" value="ä¸­ç´š" checked></label>
        <label class="cb"><span>ä¸Šç´š</span><input type="checkbox" value="ä¸Šç´š" checked></label>
      </div>

      <div class="seg">
        <label class="cb" style="min-width:160px;">
          <span>ç™»ã‚Œã‚‹å±±ã ã‘</span><input type="checkbox" id="goodOnly">
        </label>
      </div>

      <div class="seg">
        <b>è¡¨ç¤ºã‚»ãƒƒãƒˆ</b>
        <label class="cb" style="min-width:170px;"><span>ç™¾åå±±</span><input type="checkbox" id="setHYAKU" checked></label>
        <label class="cb" style="min-width:170px;"><span>èŠ±ã®ç™¾åå±±</span><input type="checkbox" id="setHANA"></label>
        <label class="cb" style="min-width:170px;"><span>äºŒç™¾åå±±</span><input type="checkbox" id="setN200"></label>
        <span class="chip" id="countChip">èª­è¾¼ä¸­...</span>
        <button id="refreshWeather"
          style="padding:6px 12px; border:1px solid var(--line); background:#fff; border-radius:8px; cursor:pointer; font-size:13px;">ğŸ”„
          å¤©æ°—ã‚’å†å–å¾—</button>
      </div>
    </div>

    <div id="setStatus"></div>
  </div>

  <div id="container">
    <div id="list"></div>
    <div id="map"></div>
  </div>


  <!-- Fullscreen overlay for mountain details (kept hidden; shown on pin click) -->
  <div id="mountainOverlay" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:9999;">
    <div
      style="position:absolute; inset:16px; background:#fff; border-radius:12px; overflow:auto; box-shadow:0 10px 30px rgba(0,0,0,.25);">
      <div
        style="position:sticky; top:0; display:flex; gap:8px; align-items:center; justify-content:space-between; padding:12px 12px; border-bottom:1px solid #e7e7e7; background:#fff;">
        <div id="mountainOverlayTitle" style="font-weight:700;"></div>
        <button id="mountainOverlayClose"
          style="border:1px solid #ddd; background:#fff; border-radius:10px; padding:6px 10px; cursor:pointer;">é–‰ã˜ã‚‹</button>
      </div>
      <div id="mountainOverlayBody" style="padding:12px 12px;"></div>
    </div>
  </div>

  <!-- Loading overlay (blocks UI only while fetching) -->
  <div id="loadingOverlay"
    style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.35); z-index:9998; align-items:center; justify-content:center;">
    <div
      style="background:#fff; padding:14px 16px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.25); font-weight:700;">
      NowLoadingâ€¦</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script type="module">
    import mountains from "./mountains.js";
    import mountainsExtra from "./mountains_extra.js";
    import { generateWeatherScore } from "./weather.js";

    /* ========= time UI ========= */
    const timeSlots = ["06:00", "08:00", "10:00", "12:00", "14:00", "16:00"];
    const timeLabels = ["06â€“08", "08â€“10", "10â€“12", "12â€“14", "14â€“16", "16â€“18"];
    const slider = document.getElementById("timeSlider");
    const timeLabel = document.getElementById("timeLabel");
    const daySelect = document.getElementById("day");

    function pad2(n) { return String(n).padStart(2, "0"); }
    const WDS = ["æ—¥", "æœˆ", "ç«", "æ°´", "æœ¨", "é‡‘", "åœŸ"];
    function getDateObj(offset) {
      const d = new Date(); d.setHours(0, 0, 0, 0); d.setDate(d.getDate() + offset);
      return d;
    }
    function formatLocalYMD(d) { return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`; }
    function getDateKey(offset) { return formatLocalYMD(getDateObj(offset)); }
    function dayLabel(offset) {
      const d = getDateObj(offset);
      const mm = pad2(d.getMonth() + 1), dd = pad2(d.getDate()), wd = WDS[d.getDay()];
      const rel = offset === 0 ? "ä»Šæ—¥" : `${offset}æ—¥å¾Œ`;
      return `${mm}/${dd}(${wd}) ${rel}`;
    }
    function initDaySelectLabels() {
      [...daySelect.options].forEach(opt => opt.textContent = dayLabel(Number(opt.value)));
    }
    initDaySelectLabels();

    function nearestTimeSlotIndexNow() {
      const now = new Date();
      const nowMin = now.getHours() * 60 + now.getMinutes();
      const starts = timeSlots.map(s => Number(s.slice(0, 2)) * 60);
      let best = 0, bestDiff = Infinity;
      starts.forEach((m, i) => {
        const diff = Math.abs(nowMin - m);
        if (diff < bestDiff) { bestDiff = diff; best = i; }
      });
      if (nowMin < starts[0]) return 0;
      if (nowMin > starts[starts.length - 1]) return starts.length - 1;
      return best;
    }

    function getSelectedTimeSlot() { return timeSlots[Number(slider.value)]; }
    function getDateOffset() { return Number(daySelect.value); }

    slider.addEventListener("input", () => {
      timeLabel.textContent = timeLabels[Number(slider.value)];
      draw();
    });

    daySelect.addEventListener("change", () => {
      if (Number(daySelect.value) === 0) {
        slider.value = String(nearestTimeSlotIndexNow());
        timeLabel.textContent = timeLabels[Number(slider.value)];
      }
      draw();
    });

    /* ========= filters ========= */
    const scoreChecks = () => [...document.querySelectorAll('input[type="checkbox"][value="A"],input[type="checkbox"][value="B"],input[type="checkbox"][value="C"]')]
      .filter(x => x.checked).map(x => x.value);

    const levelChecks = () => [...document.querySelectorAll('input[type="checkbox"][value="åˆç´š"],input[type="checkbox"][value="ä¸­ç´š"],input[type="checkbox"][value="ä¸Šç´š"]')]
      .filter(x => x.checked).map(x => x.value);

    const goodOnly = document.getElementById("goodOnly");

    const setHYAKU = document.getElementById("setHYAKU");
    const setHANA = document.getElementById("setHANA");
    const setN200 = document.getElementById("setN200");

    const setStatus = document.getElementById("setStatus");
    const countChip = document.getElementById("countChip");

    function escapeHtml(s) {
      return String(s ?? "").replace(/[&<>"']/g, c => ({
        "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
      }[c]));
    }
    function setStatusHtml(lines) {
      const safe = (lines || []).filter(Boolean).slice(0, 14).map(escapeHtml);
      setStatus.innerHTML = safe.join("<br>");
    }

    function normName(s) {
      return String(s || "")
        .replace(/\s+/g, "")
        .replace(/[â€-â€“â€”âˆ’]/g, "-")
        .trim();
    }

    /* ========= merge mountains =========
       - mountains.js(ç™¾åå±±) ã¯å¸¸ã« HYAKU ã‚»ãƒƒãƒˆæ‰±ã„
       - mountains_extra.js ã¯ _sets ã‚’å°Šé‡
       - åŒåã¯çµ±åˆã—ã¦ _sets ã‚’ union
    */
    function withDefaultSets(m) {
      const sets = Array.isArray(m._sets) ? m._sets.slice() : [];
      // ç™¾åå±±å´ã¯HYAKUã‚’ä»˜ä¸
      if (!sets.includes("HYAKU") && m.__from === "BASE") sets.push("HYAKU");
      return { ...m, _sets: sets };
    }

    function mergeAll(base, extra) {
      const map = new Map();

      base.forEach(m => {
        const key = normName(m.name);
        const mm = withDefaultSets({ ...m, __from: "BASE" });
        map.set(key, mm);
      });

      (extra || []).forEach(m => {
        const key = normName(m.name);
        if (!key) return;
        const ex = withDefaultSets({ ...m, __from: "EXTRA" });
        const cur = map.get(key);
        if (!cur) {
          map.set(key, ex);
        } else {
          // æ—¢å­˜å„ªå…ˆã§åº§æ¨™/æ¨™é«˜ãªã©ã¯æ¬ ã‘ã‚’è£œå®Œã€_sets ã¯ union
          const sets = Array.from(new Set([...(cur._sets || []), ...(ex._sets || [])]));
          map.set(key, {
            ...cur,
            lat: (cur.lat ?? ex.lat ?? null),
            lng: (cur.lng ?? ex.lng ?? null),
            elev: (cur.elev ?? ex.elev ?? null),
            level: (cur.level ?? ex.level ?? "ä¸­ç´š"),
            gpx: (cur.gpx ?? ex.gpx ?? null),
            _sets: sets
          });
        }
      });

      return [...map.values()];
    }

    const ALL = mergeAll(mountains, mountainsExtra);

    /* ========= map ========= */
    const mapObj = L.map("map").setView([36.5, 138.0], 5);

    // åœ°ç†é™¢ æ¨™æº–åœ°å›³ + é™°å½±ï¼ˆå…ƒã®æ–¹é‡ç¶­æŒï¼‰
    L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
      { attribution: "åœ°ç†é™¢ã‚¿ã‚¤ãƒ«", opacity: 0.85 }
    ).addTo(mapObj);

    L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
      { attribution: "åœ°ç†é™¢ é™°å½±", opacity: 0.45 }
    ).addTo(mapObj);

    const markerLayer = L.layerGroup().addTo(mapObj);

    /* ========= marker icons =========
       âœ… â€œãƒãƒ¼ãƒ—â€å¯¾ç­–ï¼šLeafletã‚«ãƒ©ãƒ¼æ¨™æº–ãƒãƒ¼ã‚«ãƒ¼ã«æˆ»ã™ï¼ˆè¦‹ãŸç›®ãŒå®‰å®šï¼‰
    */
    function icon(color) {
      return L.icon({
        iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
        shadowUrl: "https://unpkg.com/leaflet/dist/images/marker-shadow.png",
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41],
      });
    }
    const ICONS = {
      A: icon("green"),
      B: icon("yellow"),
      C: icon("red"),
      N: icon("grey"),
    };

    /* ========= weather cache in memory ========= */
    // mountainKey -> weatherObject
    const WX = new Map();
    const WX_META = { ok: 0, ng: 0, cacheHit: 0, lastErr: "" };

    const WX_INFLIGHT = new Map(); // key -> Promise
    const WX_FAIL = new Map(); // key -> retryAfter(ms)


    async function ensureWeatherFor(m) {
      const key = normName(m.name);

      // å–å¾—æ¸ˆã¿ã¯å³è¿”ã™ï¼ˆãƒã‚§ãƒƒã‚¯ON/OFFã§ç°è‰²ã«æˆ»ã•ãªã„ï¼‰
      if (WX.has(key)) { WX_META.cacheHit = (WX_META.cacheHit || 0) + 1; return WX.get(key); }

      const now = Date.now();
      const retryAfter = WX_FAIL.get(key) || 0;
      if (now < retryAfter) return null; // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­

      // åŒä¸€ã‚­ãƒ¼ã®åŒæ™‚å–å¾—ã‚’æŸã­ã‚‹
      if (WX_INFLIGHT.has(key)) return WX_INFLIGHT.get(key);

      const p = (async () => {
        try {
          const w = await generateWeatherScore(m.name, m.lat, m.lng, m.level || "ä¸­ç´š", m.elev ?? null);
          WX.set(key, w);
          WX_META.ok++;
          return w;
        } catch (e) {
          WX_META.ng++;
          WX_META.lastErr = String(e?.message || e);
          // å¤±æ•—ã‚’ null ã§å›ºå®šã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„ï¼ˆä»¥å¾Œã‚‚å–å¾—ã§ããªããªã‚‹ã®ã‚’é˜²ãï¼‰
          WX_FAIL.set(key, Date.now() + 30_000);
          return null;
        } finally {
          WX_INFLIGHT.delete(key);
        }
      })();

      WX_INFLIGHT.set(key, p);
      return p;
    }

    function scoreAt(m, dateKey, timeSlot) {
      const w = WX.get(normName(m.name));
      if (!w) return null;
      return w?.[dateKey]?.[timeSlot] ?? null;
    }

    function detailAt(m, dateKey, timeSlot) {
      const w = WX.get(normName(m.name));
      if (!w) return null;
      // âœ… â€œé™æ°´/é¢¨/çªé¢¨/æ°—æ¸©ãŒè¡¨ç¤ºã•ã‚Œãªã„â€ã®ä¸»å› ï¼š__detail ã‚’èª­ã‚€
      return w?.__detail?.[dateKey]?.[timeSlot] ?? null;
    }

    /* ========= set filter ========= */
    function selectedSets() {
      const s = [];
      if (setHYAKU.checked) s.push("HYAKU");
      if (setHANA.checked) s.push("HANA_100");
      if (setN200.checked) s.push("NIHON_200");
      return s;
    }
    function inSelectedSets(m) {
      const want = selectedSets();
      const has = Array.isArray(m._sets) ? m._sets : [];
      return want.some(k => has.includes(k));
    }

    /* ========= list & popup ========= */
    function scoreClass(s) {
      if (s === "A") return "scoreA";
      if (s === "B") return "scoreB";
      if (s === "C") return "scoreC";
      return "";
    }


    function scoreTableHtml(m) {
      const w = WX.get(normName(m.name));
      if (!w) return `<div class="p" style="color:var(--muted)">å¤©æ°—æœªå–å¾—</div>`;

      const days = [0, 1, 2, 3];
      const cols = days.map(d => ({ key: getDateKey(d), label: dayLabel(d) }));
      const head = `<tr><th>æ™‚é–“</th>` + cols.map(c => `<th>${escapeHtml(c.label)}</th>`).join("") + `</tr>`;

      const body = timeSlots.map((ts, i) => {
        const rowLabel = timeLabels[i] || ts;
        const tds = cols.map(c => {
          const sc = (w?.[c.key]?.[ts]) || "â€”";
          const cls = scoreClass(sc);
          return `<td class="${cls}">${escapeHtml(sc)}</td>`;
        }).join("");
        return `<tr><td class="k">${escapeHtml(rowLabel)}</td>${tds}</tr>`;
      }).join("");

      return `
        <div class="p" style="margin-top:8px">å¤©æ°—ã‚¹ã‚³ã‚¢è¡¨ï¼ˆä»Šæ—¥ã€œ3æ—¥å¾Œï¼‰</div>
        <div class="wxTableWrap"><table class="wxScoreTable">${head}${body}</table></div>
      `;
    }

    function popupHtml(m) {
      const dateOffset = getDateOffset();
      const dateKey = getDateKey(dateOffset);

      // é¸æŠæ—¥ã®ã€Œå„æ™‚é–“å¸¯ã€è©³ç´°ã‚’å‡ºã™ï¼ˆå¿…é ˆä»•æ§˜ï¼‰
      const w = WX.get(normName(m.name));
      const detailRows = timeSlots.map((ts, i) => {
        const rowLabel = timeLabels[i] || ts;
        const d = w?.__detail?.[dateKey]?.[ts] || null;
        return `
          <tr>
            <td class="k">${escapeHtml(rowLabel)}</td>
            <td>${d?.precip ?? "â€”"}</td>
            <td>${d?.wind ?? "â€”"}</td>
            <td>${d?.gust ?? "â€”"}</td>
            <td>${d?.temp ?? "â€”"}</td>
          </tr>
        `;
      }).join("");

      const sets = (m._sets || []).map(x => {
        if (x === "HYAKU") return "ç™¾";
        if (x === "HANA_100") return "èŠ±";
        if (x === "NIHON_200") return "200";
        return x;
      }).join(" / ");

      return `
        <div class="popup">
          <h3>${escapeHtml(m.name)}</h3>
          <div class="p">æ¨™é«˜: ${m.elev ?? "?"}mã€€/ã€€é›£æ˜“åº¦: ${escapeHtml(m.level ?? "ä¸­ç´š")}</div>
          <div class="p">ã‚»ãƒƒãƒˆ: ${escapeHtml(sets || "-")}</div>

          <div class="p" style="margin-top:8px">è©³ç´°ï¼ˆ${escapeHtml(dayLabel(dateOffset))} / å„æ™‚é–“å¸¯ï¼‰</div>
          <div class="wxTableWrap">
            <table class="wxScoreTable">
              <tr><th>æ™‚é–“</th><th>é™æ°´(mm)</th><th>é¢¨(m/s)</th><th>çªé¢¨(m/s)</th><th>æ°—æ¸©(â„ƒ)</th></tr>
              ${detailRows}
            </table>
          </div>

          ${scoreTableHtml(m)}
        </div>
      `;
    }


    const mountainOverlay = document.getElementById("mountainOverlay");
    const mountainOverlayTitle = document.getElementById("mountainOverlayTitle");
    const mountainOverlayBody = document.getElementById("mountainOverlayBody");
    const mountainOverlayClose = document.getElementById("mountainOverlayClose");

    function openMountainOverlay(m) {
      mountainOverlayTitle.textContent = m.name || "";
      mountainOverlayBody.innerHTML = popupHtml(m);
      mountainOverlay.style.display = "block";
    }
    function closeMountainOverlay() {
      mountainOverlay.style.display = "none";
    }
    mountainOverlayClose?.addEventListener("click", closeMountainOverlay);
    mountainOverlay?.addEventListener("click", (e) => {
      if (e.target === mountainOverlay) closeMountainOverlay();
    });

    const loadingOverlay = document.getElementById("loadingOverlay");
    function showLoading() {
      if (loadingOverlay) loadingOverlay.style.display = "flex";
    }
    function hideLoading() {
      if (loadingOverlay) loadingOverlay.style.display = "none";
    }


    /* ========= draw ========= */
    const listEl = document.getElementById("list");

    function computeCounts() {
      let hy = 0, ha = 0, n2 = 0, all = 0;
      for (const m of ALL) {
        if (m?.lat == null || m?.lng == null) continue;
        all++;
        const s = m._sets || [];
        if (s.includes("HYAKU")) hy++;
        if (s.includes("HANA_100")) ha++;
        if (s.includes("NIHON_200")) n2++;
      }
      return { hy, ha, n2, total: all };
    }

    function visibleMountains() {
      const scores = scoreChecks();
      const levels = levelChecks();
      const onlyGood = goodOnly.checked;

      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();

      return ALL
        .filter(m => m?.lat != null && m?.lng != null)
        .filter(m => inSelectedSets(m))
        .filter(m => levels.includes(m.level || "ä¸­ç´š"))
        .filter(m => {
          const sc = scoreAt(m, dateKey, timeSlot);
          if (!sc) return true; // æœªå–å¾—ã¯ä¸€æ—¦é€šã™ï¼ˆè‡ªå‹•å–å¾—ã§å¾Œã‹ã‚‰è‰²ãŒä»˜ãï¼‰
          if (!scores.includes(sc)) return false;
          if (onlyGood && sc !== "A") return false;
          return true;
        });
    }

    function sortKey(m) {
      // Aå„ªå…ˆ / æ¬¡ã«æ¨™é«˜é«˜ã„é † / åå‰
      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();
      const s = scoreAt(m, dateKey, timeSlot);
      const pri = (s === "A") ? 0 : (s === "B") ? 1 : (s === "C") ? 2 : 3;
      return { pri, elev: -(m.elev ?? 0), name: m.name };
    }

    const MARKERS = new Map(); // nameKey -> marker

    function refreshCountsUI() {
      const c = computeCounts();
      countChip.textContent = `ç™»éŒ²(åº§æ¨™ã‚ã‚Š): ç™¾=${c.hy} / èŠ±=${c.ha} / 200=${c.n2}`;
    }

    function refreshStatusUI(extraLines = []) {
      const lines = [
        `å¤©æ°—å–å¾—: OK=${WX_META.ok} / NG=${WX_META.ng}`,
        WX_META.lastErr ? `ç›´è¿‘ã‚¨ãƒ©ãƒ¼: ${WX_META.lastErr}` : "",
        ...extraLines
      ].filter(Boolean);
      setStatusHtml(lines);
    }

    function draw() {
      refreshCountsUI();

      // marker update
      markerLayer.clearLayers();
      MARKERS.clear();

      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();

      const vis = visibleMountains()
        .sort((a, b) => {
          const A = sortKey(a), B = sortKey(b);
          if (A.pri !== B.pri) return A.pri - B.pri;
          if (A.elev !== B.elev) return A.elev - B.elev;
          return String(A.name).localeCompare(String(B.name), "ja");
        });

      // list
      listEl.innerHTML = "";
      for (const m of vis) {
        const sc = scoreAt(m, dateKey, timeSlot) || "â€”";
        const sets = (m._sets || []).map(x => {
          if (x === "HYAKU") return "ç™¾";
          if (x === "HANA_100") return "èŠ±";
          if (x === "NIHON_200") return "200";
          return x;
        }).join("/");

        const item = document.createElement("div");
        item.className = "list-item";
        item.innerHTML = `
          <div class="nameLine">
            <b>${escapeHtml(m.name)}</b>
            <span class="${scoreClass(sc)}">${escapeHtml(sc)}</span>
          </div>
          <div class="metaLine">
            <span class="badge"><small>æ¨™é«˜</small>${escapeHtml(m.elev ?? "?")}m</span>
            <span class="badge"><small>é›£æ˜“åº¦</small>${escapeHtml(m.level ?? "ä¸­ç´š")}</span>
            <span class="badge"><small>ã‚»ãƒƒãƒˆ</small>${escapeHtml(sets || "-")}</span>
          </div>
        `;
        item.addEventListener("click", () => {
          const mk = MARKERS.get(normName(m.name));
          if (mk) {
            mapObj.setView([m.lat, m.lng], Math.max(mapObj.getZoom(), 9), { animate: true });
            mk.openPopup();
          }
        });
        listEl.appendChild(item);

        // marker
        const weatherScore = scoreAt(m, dateKey, timeSlot);
        const markerIcon = ICONS[weatherScore] || ICONS.N;
        const marker = L.marker([m.lat, m.lng], { icon: markerIcon });
        marker.on("click", () => openMountainOverlay(m));
        marker.addTo(markerLayer);
        MARKERS.set(normName(m.name), marker);
      }

      refreshStatusUI([`è¡¨ç¤º: ${vis.length}ä»¶ï¼ˆ${escapeHtml(dayLabel(getDateOffset()))} ${escapeHtml(timeSlot)}ï¼‰`]);

      // âœ… â€œç”»é¢ã‚’å‹•ã‹ã•ãªã„ã¨å¤©æ°—ãŒæ¥ãªã„â€å¯¾ç­–ï¼šæç”»ã®ãŸã³ã«å…ˆèª­ã¿ã‚’èµ°ã‚‰ã›ã‚‹
      prefetchWeather(vis);
    }

    /* ========= auto prefetch (rate limited) ========= */
    let PREFETCH_RUNNING = false;

    async function prefetchWeather(list) {
      if (PREFETCH_RUNNING) return;
      PREFETCH_RUNNING = true;
      showLoading();

      try {
        // ä¸€æ°—ã«æŠ•ã’ã‚‹ã¨ 429 ã«ãªã‚‹ã®ã§ã€å°‘æ•°ä¸¦åˆ— + å¾…ã¡
        const concurrency = 3;
        const queue = list.filter(m => {
          const k = normName(m.name);
          const retryAfter = WX_FAIL.get(k) || 0;
          return !WX.has(k) && !WX_INFLIGHT.has(k) && Date.now() >= retryAfter;
        });
        let idx = 0;

        async function worker() {
          while (idx < queue.length) {
            const m = queue[idx++];
            await ensureWeatherFor(m);

            // markerè‰²æ›´æ–°
            const dateKey = getDateKey(getDateOffset());
            const timeSlot = getSelectedTimeSlot();
            const sc = scoreAt(m, dateKey, timeSlot);
            const mk = MARKERS.get(normName(m.name));
            if (mk) {
              mk.setIcon(ICONS[sc] || ICONS.N);
            }
            // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤ºä¸­ã®å±±ãªã‚‰ä¸­èº«ã‚‚æ›´æ–°
            if (mountainOverlay && mountainOverlay.style.display === "block" && mountainOverlayTitle?.textContent === m.name) {
              mountainOverlayBody.innerHTML = popupHtml(m);
            }

            refreshStatusUI([`å¤©æ°—å…ˆèª­ã¿ä¸­... ${Math.min(idx, queue.length)}/${queue.length}`]);
            await new Promise(r => setTimeout(r, 120)); // è»½ãé–“å¼•ã
          }
        }

        await Promise.all(Array.from({ length: concurrency }, worker));
        refreshStatusUI([`å¤©æ°—å…ˆèª­ã¿å®Œäº†ï¼ˆæœªå–å¾—å¯¾è±¡ ${queue.length}ä»¶ / è¡¨ç¤ºä¸­ ${list.length}ä»¶ï¼‰`]);

      } finally {
        PREFETCH_RUNNING = false;
        hideLoading();
      }
    }

    /* ========= events ========= */
    document.querySelectorAll('#control input[type="checkbox"]').forEach(el => {
      el.addEventListener("change", draw);
    });

    // å¤©æ°—å†å–å¾—ãƒœã‚¿ãƒ³
    document.getElementById("refreshWeather")?.addEventListener("click", () => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      WX.clear();
      WX_FAIL.clear();
      WX_META.ok = 0;
      WX_META.ng = 0;
      WX_META.cacheHit = 0;
      WX_META.lastErr = "";
      // å†æç”»ï¼ˆè‡ªå‹•çš„ã«å¤©æ°—ã‚’å†å–å¾—ï¼‰
      draw();
    });

    // init
    slider.value = String(nearestTimeSlotIndexNow());
    timeLabel.textContent = timeLabels[Number(slider.value)];
    draw();
  </script>
</body>

</html>