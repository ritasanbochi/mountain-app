<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>登山向け山岳マップ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>

<style>
  body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }

  #control{
    padding:10px;
    background:#f4f4f4;
    font-size:14px;
    display:flex;
    flex-wrap:wrap;
    gap:8px 10px;
    align-items:center;
  }
  #control b{ margin-right:4px; }
  #control label{ white-space:nowrap; }
  #control .group{
    display:flex;
    flex-wrap:wrap;
    gap:6px 10px;
    align-items:center;
    padding:4px 6px;
    border:1px solid #ddd;
    border-radius:10px;
    background:#fff;
  }

  #container{ height:calc(100vh - 120px); position:relative; }
  #map{ height:100%; width:100%; }

  #list{
    position:absolute;
    top:0; right:0;
    width:320px; height:100%;
    overflow-y:auto;
    background:#fff;
    border-left:1px solid #ccc;
    font-size:13px;
    z-index:1000;
  }
  .list-item{
    border-bottom:1px solid #ddd;
    padding:8px;
    cursor:pointer;
  }
  .list-item:hover{ background:#eef6ff; }

  .star{ color:gold; font-weight:bold; }

  .badge{
    display:inline-block;
    padding:1px 6px;
    border-radius:10px;
    font-size:11px;
    margin-left:6px;
    vertical-align:1px;
  }
  .badge-api{ background:#e7f7ea; border:1px solid #9ad3a5; }
  .badge-dummy{ background:#fff0f0; border:1px solid #e0a3a3; }

  .setpill{
    display:inline-block;
    padding:1px 6px;
    border-radius:999px;
    font-size:11px;
    border:1px solid #ddd;
    background:#fafafa;
    margin-left:6px;
  }

  hr{ border:none; border-top:1px solid #ddd; margin:8px 0; }
  small{ color:#555; }

  #detailOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.35);
    z-index:9999;
    display:none;
  }
  #detailOverlay.show{ display:block; }

  #detailPanel{
    position:absolute;
    inset:0;
    background:#fff;
    display:flex;
    flex-direction:column;
  }
  #detailHeader{
    position:sticky;
    top:0;
    background:#fff;
    border-bottom:1px solid #ddd;
    padding:10px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  #detailHeader b{
    font-size:16px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    max-width:70%;
  }
  #detailClose{
    appearance:none;
    border:1px solid #ccc;
    background:#f7f7f7;
    padding:6px 10px;
    border-radius:8px;
    font-size:14px;
  }
  #detailBody{
    padding:12px;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    line-height:1.5;
  }

  @media (min-width:769px){
    #detailPanel{
      inset:auto;
      top:24px; left:50%;
      transform:translateX(-50%);
      width:min(980px, calc(100vw - 48px));
      height:min(86vh, 900px);
      border-radius:14px;
      box-shadow:0 14px 40px rgba(0,0,0,0.24);
    }
  }

  .wx-table{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  .wx-table th, .wx-table td{
    border:1px solid #ddd;
    padding:4px 6px;
    text-align:center;
  }
  .wx-table th{
    background:#f7f7f7;
    font-weight:600;
  }
  .wx-current{ background:#eef6ff; font-weight:700; }

  .score-grid{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  .score-grid td, .score-grid th{
    border:1px solid #ddd;
    padding:4px 0;
    text-align:center;
  }
  .score-grid th{ background:#f7f7f7; font-weight:600; }
  .score-grid .sel{
    outline:2px solid #5aa7ff;
    outline-offset:-2px;
    font-weight:800;
    background:#eef6ff;
  }
  .score-grid .a{ background:#eaf7ee; }
  .score-grid .b{ background:#fff7db; }
  .score-grid .c{ background:#ffe7e7; }

  #listHeader{ display:none; }
  #listTab{ display:none; }

  @media (max-width:768px){
    #list{
      position:fixed;
      left:0; right:0;
      bottom:0; top:auto;
      width:100%;
      height:45vh;
      border-left:none;
      border-top:1px solid #ccc;
      border-radius:14px 14px 0 0;
      box-shadow: 0 -6px 18px rgba(0,0,0,0.08);
      overflow:hidden;
      z-index:2000;
      transform: translateY(0);
      transition: transform 220ms ease;
      touch-action: pan-y;
      background:#fff;
    }
    #list.is-collapsed{ transform: translateY(100%); }

    #listHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      background:#fff;
      border-bottom:1px solid #eee;
      user-select:none;
    }
    #listHeader .title{ font-weight:700; font-size:14px; }
    #listHeader .grip{
      width:42px; height:5px;
      border-radius:999px;
      background:#d8d8d8;
      margin:0 10px;
    }
    #listHeader .hint{
      font-size:12px;
      color:#666;
      white-space:nowrap;
    }

    #listBody{
      height:calc(45vh - 48px);
      overflow:auto;
      -webkit-overflow-scrolling:touch;
    }

    #listTab{
      display:block;
      position:fixed;
      left:12px;
      bottom:12px;
      z-index:2500;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid #cfcfcf;
      background:#fff;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      font-size:13px;
    }
    #listTab.hidden{ display:none; }
  }
</style>
</head>

<body>
<div id="control">
  <div class="group">
    <b>日付</b>
    <select id="day">
      <option value="0">今日</option>
      <option value="1">1日後</option>
      <option value="2">2日後</option>
      <option value="3">3日後</option>
    </select>

    <b>時間帯</b>
    <input type="range" id="timeSlider" min="0" max="5" value="0">
    <span id="timeLabel">06–08</span>
  </div>

  <div class="group">
    <b>山セット</b>
    <label><input type="checkbox" class="setChk" value="HYAKU" checked>百名山</label>
    <label><input type="checkbox" class="setChk" value="HANA_100">花の百名山</label>
    <label><input type="checkbox" class="setChk" value="NIHON_200">二百名山</label>
    <label><input type="checkbox" class="setChk" value="NIHON_300">三百名山</label>
  </div>

  <div class="group">
    <b>天気</b>
    <label><input type="checkbox" value="A" checked>A</label>
    <label><input type="checkbox" value="B" checked>B</label>
    <label><input type="checkbox" value="C" checked>C</label>
  </div>

  <div class="group">
    <b>難易度</b>
    <label><input type="checkbox" value="初級" checked>初級</label>
    <label><input type="checkbox" value="中級" checked>中級</label>
    <label><input type="checkbox" value="上級" checked>上級</label>
    <label style="margin-left:6px;"><input type="checkbox" id="goodOnly"> 登れる山だけ</label>
  </div>

  <div class="group">
    <span id="setStatus" style="font-size:12px;color:#444;"></span>
  </div>
</div>

<div id="container">
  <div id="map"></div>

  <div id="list">
    <div id="listHeader">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="grip" aria-hidden="true"></div>
        <div class="title">山リスト</div>
      </div>
      <div class="hint">下へスワイプ / タップで隠す</div>
    </div>
    <div id="listBody"></div>
  </div>
</div>

<button id="listTab" class="hidden" type="button">山リスト</button>

<div id="detailOverlay" aria-hidden="true">
  <div id="detailPanel" role="dialog" aria-modal="true" aria-label="山の詳細">
    <div id="detailHeader">
      <b id="detailTitle">山の詳細</b>
      <button id="detailClose" type="button">閉じる</button>
    </div>
    <div id="detailBody"></div>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script type="module">
import mountains from "./mountains.js";
import { loadSetNames, SET_DEFS, GEO_OVERRIDES } from "./mountaimSets.js";
import { generateWeatherScore } from "./weather.js";

/* ===== 時間帯 ===== */
const timeSlots  = ["06:00","08:00","10:00","12:00","14:00","16:00"];
const timeLabels = ["06–08","08–10","10–12","12–14","14–16","16–18"];

const slider = document.getElementById("timeSlider");
const timeLabel = document.getElementById("timeLabel");
const daySelect = document.getElementById("day");
const setStatus = document.getElementById("setStatus");

function nearestTimeSlotIndexNow(){
  const now = new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();
  const starts = timeSlots.map(s => Number(s.slice(0,2)) * 60);
  let bestIdx = 0, bestDiff = Infinity;
  starts.forEach((min, idx) => {
    const diff = Math.abs(nowMin - min);
    if (diff < bestDiff) { bestDiff = diff; bestIdx = idx; }
  });
  if (nowMin < starts[0]) return 0;
  if (nowMin > starts[starts.length - 1] + 120) return starts.length - 1;
  return bestIdx;
}
function setSliderIndex(idx){
  slider.value = String(idx);
  timeLabel.textContent = timeLabels[idx];
}
slider.oninput = () => {
  timeLabel.textContent = timeLabels[Number(slider.value)];
  updateView();
};
const getSelectedTime = () => timeSlots[Number(slider.value)];

daySelect.addEventListener("change", () => {
  if (Number(daySelect.value) === 0) setSliderIndex(nearestTimeSlotIndexNow());
  updateView();
});

function pad2(n){ return String(n).padStart(2, "0"); }
function formatLocalYMD(d){
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}
function getDateKey(offset){
  const d = new Date();
  d.setHours(0,0,0,0);
  d.setDate(d.getDate() + offset);
  return formatLocalYMD(d);
}

const WDS = ["日","月","火","水","木","金","土"];
function getDateObj(offset){
  const d = new Date();
  d.setHours(0,0,0,0);
  d.setDate(d.getDate() + offset);
  return d;
}
function dayLabel(offset){
  const d = getDateObj(offset);
  const mm = pad2(d.getMonth()+1);
  const dd = pad2(d.getDate());
  const wd = WDS[d.getDay()];
  const rel = offset === 0 ? "今日" : `${offset}日後`;
  return `${mm}/${dd}(${wd}) ${rel}`;
}
function initDaySelectLabels(){
  [...daySelect.options].forEach(opt => {
    const off = Number(opt.value);
    opt.textContent = dayLabel(off);
  });
}

/* ===== 地図 ===== */
const map = L.map("map").setView([36.5, 138], 5);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
  { opacity: 0.5, attribution:"地理院 陰影" }
).addTo(map);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
  { opacity: 0.85, attribution:"地理院 地図" }
).addTo(map);

const markerLayer = L.layerGroup().addTo(map);

/* ===== アイコン ===== */
const icon = color => L.icon({
  iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
  shadowUrl: "https://unpkg.com/leaflet/dist/images/marker-shadow.png",
  iconSize: [25,41],
  iconAnchor: [12,41]
});
const icons = { A:icon("green"), B:icon("yellow"), C:icon("red") };
const scorePriority = { A:3, B:2, C:1 };

/* ===== utils ===== */
function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}
function fmt(n, digits=1){
  if (n === null || n === undefined) return "-";
  const v = Number(n);
  return Number.isFinite(v) ? v.toFixed(digits) : "-";
}
function fmtJpDateTime(iso){
  if (!iso) return "-";
  const d = new Date(iso);
  if (!Number.isFinite(d.getTime())) return "-";
  return `${d.getFullYear()}/${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
}
function timeAgo(iso){
  if (!iso) return "-";
  const t = new Date(iso).getTime();
  if (!Number.isFinite(t)) return "-";
  const sec = Math.floor((Date.now() - t) / 1000);
  if (sec < 60) return `${sec}s前`;
  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}分前`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}時間前`;
  const day = Math.floor(hr / 24);
  return `${day}日前`;
}
function getDetail(m, dateKey, time){
  return m.weather?._details?.[dateKey]?.[time] ?? null;
}
function getBestTime(weather, dateKey){
  const w = weather?.[dateKey];
  if (!w) return null;
  let best = null;
  for (const t of timeSlots) {
    const s = w[t];
    if (!s) continue;
    if (!best || scorePriority[s] > scorePriority[best.score]) best = { time:t, score:s };
  }
  return best;
}
function scoreCellClass(score){
  if (score === "A") return "a";
  if (score === "B") return "b";
  if (score === "C") return "c";
  return "";
}
function buildScoreGridHtml(m, selDay, selTime){
  const head = `
    <thead>
      <tr>
        <th style="width:18%"></th>
        ${timeLabels.map(l => `<th>${l}</th>`).join("")}
      </tr>
    </thead>
  `;
  const bodyRows = [];
  for (let d = 0; d <= 3; d++){
    const dk = getDateKey(d);
    const tds = timeSlots.map(t => {
      const s = m.weather?.[dk]?.[t] ?? "-";
      const base = scoreCellClass(s);
      const sel = (d === selDay && t === selTime) ? "sel" : "";
      return `<td class="${base} ${sel}">${s ?? "-"}</td>`;
    }).join("");
    bodyRows.push(`<tr><th>${escapeHtml(dayLabel(d))}</th>${tds}</tr>`);
  }
  return `
    <b>スコア早見表（今日〜3日後 × 全時間帯）</b><br>
    <table class="score-grid">
      ${head}
      <tbody>${bodyRows.join("")}</tbody>
    </table>
    <small>※ 選択中の日付×時間は枠線で強調</small>
  `;
}

/* ===== セット表示 ===== */
function setLabel(k){
  return ({
    HYAKU:"百名山",
    HANA_100:"花100",
    NIHON_200:"二百名山",
    NIHON_300:"三百名山"
  }[k] ?? (SET_DEFS?.[k]?.label ?? k));
}
function normName(s){
  return String(s ?? "")
    .trim()
    .replace(/\s+/g,"")
    .replace(/[（(].*?[）)]/g,"");
}

/* ===== master ===== */
const byName = new Map();
function upsertMountain(base){
  const key = normName(base.name);
  if (!key) return null;
  if (!byName.has(key)){
    const m = { ...base, _sets: new Set(base._sets ?? []) };
    byName.set(key, m);
  }else{
    const m = byName.get(key);
    if (m.lat == null && base.lat != null) m.lat = base.lat;
    if (m.lng == null && base.lng != null) m.lng = base.lng;
    if (m.elev == null && base.elev != null) m.elev = base.elev;
    if (!m.level && base.level) m.level = base.level;
    (base._sets ?? []).forEach(s => m._sets.add(s));
  }
  return byName.get(key);
}
mountains.forEach(m => upsertMountain({ ...m, _sets:["HYAKU"] }));

/* ===== セットロード管理（山名だけ） ===== */
const loadedSetKeys = new Set();

/* ===== Geocoding（Open-Meteo） + overrides ===== */
const GEO_CACHE_KEY = "mount_geo_openmeteo_v2";
const geoCache = (() => { try { return JSON.parse(localStorage.getItem(GEO_CACHE_KEY)||"{}")||{}; } catch { return {}; } })();
function saveGeoCache(){ try { localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geoCache)); } catch {} }

function isJapanLike(lat,lng){
  return lat >= 24 && lat <= 46.5 && lng >= 122 && lng <= 146.5;
}
async function openMeteoGeocode(query){
  const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=10&language=ja&format=json`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`geocode ${res.status}`);
  const j = await res.json();
  const r = j?.results;
  if (!Array.isArray(r) || r.length === 0) return null;

  const jp = r.find(x => isJapanLike(Number(x.latitude), Number(x.longitude))) || r[0];
  const lat = Number(jp.latitude), lng = Number(jp.longitude);
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
  const elev = (jp.elevation != null && Number.isFinite(Number(jp.elevation))) ? Number(jp.elevation) : null;
  return { lat, lng, elev };
}
async function resolveGeo(name){
  const key = normName(name);
  if (!key) return null;

  const ov = GEO_OVERRIDES?.[name] || GEO_OVERRIDES?.[key];
  if (ov?.lat && ov?.lng){
    return { lat:Number(ov.lat), lng:Number(ov.lng), elev:(ov.elev!=null?Number(ov.elev):null), source:"override" };
  }
  if (geoCache[key]) return { ...geoCache[key], source:"cache" };

  const tries = [name, `${name} 日本`, `${name} 山 日本`];
  for (const q of tries){
    try{
      const g = await openMeteoGeocode(q);
      if (g){
        geoCache[key] = { lat:g.lat, lng:g.lng, elev:g.elev };
        saveGeoCache();
        return { ...geoCache[key], source:"geocode" };
      }
    }catch{}
  }
  return null;
}

/* ===== マーカー（再生成NG：未作成だけ追加） ===== */
const markerEntries = [];
const markerByKey = new Map();
function addMarkerForMountain(m){
  const key = normName(m.name);
  if (!key || markerByKey.has(key)) return;
  if (m.lat == null || m.lng == null) return;

  const marker = L.marker([m.lat, m.lng], { icon: icons["C"] });
  marker.on("click", () => {
    map.setView([m.lat, m.lng], Math.max(map.getZoom(), 10));
    openDetail(m, marker);
  });

  markerEntries.push({ m, marker, shown:false });
  markerByKey.set(key, marker);
}

/* ===== フィルタ ===== */
function getState(){
  const day = Number(daySelect.value);
  const time = getSelectedTime();
  const dateKey = getDateKey(day);
  const goodOnly = document.getElementById("goodOnly").checked;

  const scores = [...document.querySelectorAll(
    'input[value="A"]:checked,input[value="B"]:checked,input[value="C"]:checked'
  )].map(e => e.value);

  const levels = [...document.querySelectorAll(
    'input[value="初級"]:checked,input[value="中級"]:checked,input[value="上級"]:checked'
  )].map(e => e.value);

  const sets = [...document.querySelectorAll('.setChk:checked')].map(e => e.value);
  return { day, time, dateKey, goodOnly, scores, levels, sets };
}
function mountainInSelectedSets(m, sets){
  if (!sets?.length) return true;
  const ms = m._sets;
  if (!ms || ms.size === 0) return false;
  return sets.some(s => ms.has(s));
}

/* ===== 追加セット（山名）を byName に投入 ===== */
async function ensureSetLoaded(setKey){
  if (setKey === "HYAKU") return;
  if (loadedSetKeys.has(setKey)) return;
  if (!SET_DEFS?.[setKey]) return;

  setStatus.textContent = `${setLabel(setKey)}: 山名取得中...`;
  const { names, meta } = await loadSetNames(setKey);

  for (const name of names){
    const key = normName(name);
    if (!key) continue;

    if (byName.has(key)){
      byName.get(key)._sets.add(setKey);
      continue;
    }
    byName.set(key, {
      name,
      lat:null, lng:null, elev:null,
      level:"中級",
      gpx:null,
      weather:{},
      _sets: new Set([setKey]),
      _setMeta: meta
    });
  }

  loadedSetKeys.add(setKey);
  setStatus.textContent = `${setLabel(setKey)}: ${names.length}件（${meta?.cached ? "cache" : "fresh"}）`;
}

/* ===== 追加処理（座標→天気→マーカー） ===== */
let resolving = false;
async function resolveForEnabledSets(){
  if (resolving) return;

  const { sets } = getState();
  if (!sets.length) return;

  const pending = [];
  for (const m of byName.values()){
    if (!mountainInSelectedSets(m, sets)) continue;
    if (m.lat != null && m.lng != null && m.weather && Object.keys(m.weather).length) continue;
    pending.push(m);
  }
  if (!pending.length) return;

  resolving = true;
  let okGeo=0, ngGeo=0, okWx=0, ngWx=0;

  // 安全のため 40件ずつ
  for (const m of pending.slice(0, 40)){
    try{
      if (m.lat == null || m.lng == null){
        const g = await resolveGeo(m.name);
        if (!g){ ngGeo++; continue; }
        m.lat = g.lat; m.lng = g.lng;
        if (m.elev == null && g.elev != null) m.elev = Math.round(g.elev);
        okGeo++;
      } else {
        okGeo++;
      }

      addMarkerForMountain(m);

      if (!m.weather || Object.keys(m.weather).length === 0){
        try{
          m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
          okWx++;
        }catch{
          ngWx++;
        }
      }
    }catch{
      ngGeo++;
    }
  }

  resolving = false;
  setStatus.textContent = `追加処理: 座標OK${okGeo}/NG${ngGeo} 天気OK${okWx}/NG${ngWx}（続きはもう一度操作）`;
}

/* ===== 詳細 ===== */
const detailOverlay = document.getElementById("detailOverlay");
const detailTitle = document.getElementById("detailTitle");
const detailBody = document.getElementById("detailBody");
const detailClose = document.getElementById("detailClose");
let currentDetail = null;

function detailHtml(m, selectedTime){
  const day = Number(daySelect.value);
  const dateKey = getDateKey(day);
  const grid = buildScoreGridHtml(m, day, selectedTime);

  const rows = timeSlots.map((t, idx) => {
    const s = m.weather?.[dateKey]?.[t] ?? "-";
    const d = getDetail(m, dateKey, t);
    const cls = (t === selectedTime) ? "wx-current" : "";
    return `
      <tr class="${cls}">
        <td>${timeLabels[idx]}</td>
        <td><b>${s ?? "-"}</b></td>
        <td>${d ? fmt(d.precipitation,1) : "-"}</td>
        <td>${d ? `${fmt(d.windspeed_mid,1)}→${fmt(d.windspeed_summit,1)}` : "-"}</td>
        <td>${d ? `${fmt(d.gust_mid,1)}→${fmt(d.gust_summit,1)}` : "-"}</td>
        <td>${d ? `${fmt(d.temp_mid,1)}→${fmt(d.temp_summit,1)}` : "-"}</td>
      </tr>
    `;
  }).join("");

  const setPills = m._sets?.size
    ? [...m._sets].map(s => `<span class="setpill">${escapeHtml(setLabel(s))}</span>`).join("")
    : "";

  return `
    <div class="popup">
      <b>${escapeHtml(m.name)}</b>${setPills}<br>
      標高：${m.elev ?? "-"} m / 難易度：${escapeHtml(m.level)}<br>

      <hr>
      ${grid}

      <hr>
      <b>${escapeHtml(dayLabel(day))} の根拠（時間帯別）</b><br>
      <table class="wx-table">
        <thead>
          <tr>
            <th>時間</th><th>スコア</th><th>降水(mm)</th><th>風(m/s)</th><th>突風(m/s)</th><th>気温(℃)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <small>※ 風/突風/気温は「中腹→山頂」</small>
    </div>
  `;
}

function openDetail(m, marker){
  currentDetail = { mountain: m, marker };
  detailTitle.textContent = m.name;
  detailBody.innerHTML = detailHtml(m, getSelectedTime());
  detailOverlay.classList.add("show");
  detailOverlay.setAttribute("aria-hidden","false");
  document.body.style.overflow = "hidden";
}
function closeDetail(){
  detailOverlay.classList.remove("show");
  detailOverlay.setAttribute("aria-hidden","true");
  detailBody.innerHTML = "";
  document.body.style.overflow = "";
  currentDetail = null;
}
detailClose.onclick = closeDetail;
detailOverlay.addEventListener("click", (e) => {
  if (e.target === detailOverlay) closeDetail();
});
window.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && detailOverlay.classList.contains("show")) closeDetail();
});

/* ===== リスト ===== */
const listEl = document.getElementById("list");
const listHeaderEl = document.getElementById("listHeader");
const listBodyEl = document.getElementById("listBody");
const listTabEl = document.getElementById("listTab");

function isMobile(){ return window.matchMedia && window.matchMedia("(max-width:768px)").matches; }
let listCollapsed = false;
function setListCollapsed(v){
  listCollapsed = v;
  if (isMobile()){
    listEl.classList.toggle("is-collapsed", v);
    listTabEl.classList.toggle("hidden", !v);
  }else{
    listEl.classList.remove("is-collapsed");
    listTabEl.classList.add("hidden");
  }
}
function initMobileListGestures(){
  if (!isMobile()) return;
  listTabEl.onclick = () => setListCollapsed(false);

  let startY = 0, lastDy = 0, dragging = false;
  listHeaderEl.addEventListener("touchstart", (e) => {
    if (!e.touches?.length) return;
    startY = e.touches[0].clientY;
    lastDy = 0;
    dragging = true;
    listEl.style.transition = "none";
  }, { passive:true });

  listHeaderEl.addEventListener("touchmove", (e) => {
    if (!dragging || !e.touches?.length) return;
    const y = e.touches[0].clientY;
    const dy = Math.max(0, y - startY);
    lastDy = dy;
    listEl.style.transform = `translateY(${Math.min(dy, 260)}px)`;
  }, { passive:true });

  listHeaderEl.addEventListener("touchend", () => {
    if (!dragging) return;
    dragging = false;
    listEl.style.transition = "";
    listEl.style.transform = "";
    if (lastDy > 120) setListCollapsed(true);
  });

  window.addEventListener("resize", () => {
    setListCollapsed(isMobile() ? listCollapsed : false);
  });
}
function drawList(items, day){
  const target = isMobile() ? listBodyEl : listEl;

  if (isMobile()){
    target.innerHTML = `<div style="padding:8px 10px; font-weight:700;">${escapeHtml(dayLabel(day))} の山</div>`;
  } else {
    target.innerHTML = `<b>${escapeHtml(dayLabel(day))} の山</b><br>`;
  }

  items.forEach(({ m, best, marker }) => {
    const meta = m.weather?._meta || {};
    const isApiSrc = meta.source === "api";
    const badgeClass = isApiSrc ? "badge-api" : "badge-dummy";
    const srcText = isApiSrc ? "API" : "DUMMY";

    const setPills = m._sets?.size
      ? [...m._sets].map(s => `<span class="setpill">${escapeHtml(setLabel(s))}</span>`).join("")
      : "";

    const div = document.createElement("div");
    div.className = "list-item";
    div.innerHTML = `
      <b>${escapeHtml(m.name)}</b>
      ${best?.score==="A" ? "<span class='star'>★</span>" : ""}
      <span class="badge ${badgeClass}">${srcText}</span>
      ${setPills}
      <br>
      標高:${m.elev ?? "-"}m / ${escapeHtml(m.level)}<br>
      ベスト:${best ? `${best.time}（${best.score}）` : "-"}<br>
      <small>取得:${fmtJpDateTime(meta.fetchedAt)}（${timeAgo(meta.fetchedAt)}）</small>
    `;
    div.onclick = () => {
      if (isMobile()) setListCollapsed(true);
      map.setView([m.lat, m.lng], 11);
      openDetail(m, marker);
    };
    target.appendChild(div);
  });
}

/* ===== update ===== */
function updateView(){
  const { day, time, dateKey, goodOnly, scores, levels, sets } = getState();
  const items = [];

  for (const entry of markerEntries){
    const m = entry.m;
    const marker = entry.marker;

    const score = m.weather?.[dateKey]?.[time];
    const pass =
      !!score &&
      scores.includes(score) &&
      levels.includes(m.level) &&
      mountainInSelectedSets(m, sets) &&
      !(goodOnly && (score !== "A" || m.level === "上級"));

    if (pass){
      if (!entry.shown){
        markerLayer.addLayer(marker);
        entry.shown = true;
      }
      marker.setIcon(icons[score]);
      const best = getBestTime(m.weather, dateKey);
      items.push({ m, best, marker });
    }else{
      if (entry.shown){
        markerLayer.removeLayer(marker);
        entry.shown = false;
      }
      if (currentDetail?.mountain === m) closeDetail();
    }
  }

  drawList(items, day);

  if (currentDetail?.mountain){
    detailTitle.textContent = currentDetail.mountain.name;
    detailBody.innerHTML = detailHtml(currentDetail.mountain, time);
  }

  setTimeout(() => map.invalidateSize(), 60);
}

/* ===== init ===== */
async function init(){
  initDaySelectLabels();
  if (Number(daySelect.value) === 0) setSliderIndex(nearestTimeSlotIndexNow());

  // 百名山は先に天気生成
  const baseList = [...byName.values()].filter(m => m._sets?.has("HYAKU") && m.lat != null && m.lng != null);
  await Promise.all(baseList.map(async m => {
    if (!m.weather || Object.keys(m.weather).length === 0){
      m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
    }
  }));
  for (const m of baseList) addMarkerForMountain(m);

  // UIイベント
  document.querySelectorAll("#control input,#control select").forEach(e => {
    if (e === daySelect) return;
    e.addEventListener("change", async () => {
      const { sets } = getState();
      for (const s of sets) await ensureSetLoaded(s);
      await resolveForEnabledSets();
      updateView();
    });
  });

  initMobileListGestures();
  setListCollapsed(isMobile() ? true : false);

  updateView();
}
init();
</script>
</body>
</html>
