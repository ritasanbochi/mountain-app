<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>登山向け山岳マップ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<link rel="icon" href="data:,">

<style>
  body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }
  #control{
    padding:10px; background:#f4f4f4; font-size:14px;
    display:flex; flex-wrap:wrap; gap:8px 10px; align-items:center;
  }
  #control b{ margin-right:4px; }
  #control label{ white-space:nowrap; }
  #control .group{
    display:flex; flex-wrap:wrap; gap:6px 10px; align-items:center;
    padding:4px 6px; border:1px solid #ddd; border-radius:10px; background:#fff;
  }
  .btn{ border:1px solid #cfcfcf; background:#fff; padding:6px 10px; border-radius:10px; font-size:13px; cursor:pointer; }
  .btn:hover{ background:#f7f7f7; }
  .chip{ display:inline-block; padding:1px 8px; border-radius:999px; background:#eef6ff; border:1px solid #b7d7ff; font-size:12px; margin-left:6px; }
  .danger{ background:#ffe7e7; border:1px solid #ffb8b8; }
  .ok{ background:#eaf7ee; border:1px solid #9ad3a5; }

  #container{ height:calc(100vh - 160px); position:relative; }
  #map{ height:100%; width:100%; }

  #list{
    position:absolute; top:0; right:0;
    width:320px; height:100%; overflow-y:auto;
    background:#fff; border-left:1px solid #ccc; font-size:13px; z-index:1000;
  }
  .list-item{ border-bottom:1px solid #ddd; padding:8px; cursor:pointer; }
  .list-item:hover{ background:#eef6ff; }
  .star{ color:gold; font-weight:bold; }
  .badge{ display:inline-block; padding:1px 6px; border-radius:10px; font-size:11px; margin-left:6px; vertical-align:1px; }
  .badge-api{ background:#e7f7ea; border:1px solid #9ad3a5; }
  .badge-dummy{ background:#fff0f0; border:1px solid #e0a3a3; }
  .setpill{ display:inline-block; padding:1px 6px; border-radius:999px; font-size:11px; border:1px solid #ddd; background:#fafafa; margin-left:6px; }
  hr{ border:none; border-top:1px solid #ddd; margin:8px 0; }
  small{ color:#555; }

  #detailOverlay{ position:fixed; inset:0; background:rgba(0,0,0,0.35); z-index:9999; display:none; }
  #detailOverlay.show{ display:block; }
  #detailPanel{ position:absolute; inset:0; background:#fff; display:flex; flex-direction:column; }
  #detailHeader{
    position:sticky; top:0; background:#fff; border-bottom:1px solid #ddd;
    padding:10px 12px; display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  #detailHeader b{ font-size:16px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:70%; }
  #detailClose{ border:1px solid #ccc; background:#f7f7f7; padding:6px 10px; border-radius:8px; font-size:14px; }
  #detailBody{ padding:12px; overflow:auto; -webkit-overflow-scrolling:touch; line-height:1.5; }

  @media (min-width:769px){
    #detailPanel{
      inset:auto; top:24px; left:50%; transform:translateX(-50%);
      width:min(980px, calc(100vw - 48px)); height:min(86vh, 900px);
      border-radius:14px; box-shadow:0 14px 40px rgba(0,0,0,0.24);
    }
  }

  .wx-table{ width:100%; border-collapse:collapse; font-size:12px; }
  .wx-table th, .wx-table td{ border:1px solid #ddd; padding:4px 6px; text-align:center; }
  .wx-table th{ background:#f7f7f7; font-weight:600; }
  .wx-current{ background:#eef6ff; font-weight:700; }

  .score-grid{ width:100%; border-collapse:collapse; font-size:12px; }
  .score-grid td, .score-grid th{ border:1px solid #ddd; padding:4px 0; text-align:center; }
  .score-grid th{ background:#f7f7f7; font-weight:600; }
  .score-grid .sel{ outline:2px solid #5aa7ff; outline-offset:-2px; font-weight:800; background:#eef6ff; }
  .score-grid .a{ background:#eaf7ee; } .score-grid .b{ background:#fff7db; } .score-grid .c{ background:#ffe7e7; }

  #listHeader{ display:none; } #listTab{ display:none; }
  @media (max-width:768px){
    #container{ height:calc(100vh - 200px); }
    #list{
      position:fixed; left:0; right:0; bottom:0; top:auto; width:100%; height:45vh;
      border-left:none; border-top:1px solid #ccc; border-radius:14px 14px 0 0;
      box-shadow: 0 -6px 18px rgba(0,0,0,0.08);
      overflow:hidden; z-index:2000;
      transform: translateY(0); transition: transform 220ms ease;
      touch-action: pan-y; background:#fff;
    }
    #list.is-collapsed{ transform: translateY(100%); }
    #listHeader{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px; background:#fff; border-bottom:1px solid #eee; user-select:none;
    }
    #listHeader .title{ font-weight:700; font-size:14px; }
    #listHeader .grip{ width:42px; height:5px; border-radius:999px; background:#d8d8d8; margin:0 10px; }
    #listHeader .hint{ font-size:12px; color:#666; white-space:nowrap; }
    #listBody{ height:calc(45vh - 48px); overflow:auto; -webkit-overflow-scrolling:touch; }
    #listTab{
      display:block; position:fixed; left:12px; bottom:12px; z-index:2500;
      padding:10px 12px; border-radius:999px; border:1px solid #cfcfcf; background:#fff;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12); font-size:13px;
    }
    #listTab.hidden{ display:none; }
  }
</style>
</head>

<body>
<div id="control">
  <div class="group">
    <b>日付</b>
    <select id="day">
      <option value="0">今日</option>
      <option value="1">1日後</option>
      <option value="2">2日後</option>
      <option value="3">3日後</option>
    </select>

    <b>時間帯</b>
    <input type="range" id="timeSlider" min="0" max="5" value="0">
    <span id="timeLabel">06–08</span>
  </div>

  <div class="group">
    <b>山セット</b>
    <label><input type="checkbox" class="setChk" value="HYAKU" checked>百名山</label>
    <label><input type="checkbox" class="setChk" value="HANA_100">花の百名山</label>
    <label><input type="checkbox" class="setChk" value="NIHON_200">二百名山</label>
    <label><input type="checkbox" class="setChk" value="NIHON_300">三百名山</label>
  </div>

  <div class="group">
    <b>天気</b>
    <label><input type="checkbox" value="A" checked>A</label>
    <label><input type="checkbox" value="B" checked>B</label>
    <label><input type="checkbox" value="C" checked>C</label>
  </div>

  <div class="group">
    <b>難易度</b>
    <label><input type="checkbox" value="初級" checked>初級</label>
    <label><input type="checkbox" value="中級" checked>中級</label>
    <label><input type="checkbox" value="上級" checked>上級</label>
    <label style="margin-left:6px;"><input type="checkbox" id="goodOnly"> 登れる山だけ</label>
  </div>

  <div class="group">
    <button id="buildExtra" class="btn" type="button">自動取得→mountains_extra.js生成</button>
    <button id="resetBuild" class="btn" type="button">生成進捗リセット</button>
    <span class="chip" id="exportHint" style="display:none;"></span>
  </div>

  <div class="group">
    <span id="setStatus" style="font-size:12px;color:#444; max-width: 76vw;"></span>
  </div>
</div>

<div id="container">
  <div id="map"></div>
  <div id="list">
    <div id="listHeader">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="grip" aria-hidden="true"></div>
        <div class="title">山リスト</div>
      </div>
      <div class="hint">下へスワイプ / タップで隠す</div>
    </div>
    <div id="listBody"></div>
  </div>
</div>

<button id="listTab" class="hidden" type="button">山リスト</button>

<div id="detailOverlay" aria-hidden="true">
  <div id="detailPanel" role="dialog" aria-modal="true" aria-label="山の詳細">
    <div id="detailHeader">
      <b id="detailTitle">山の詳細</b>
      <button id="detailClose" type="button">閉じる</button>
    </div>
    <div id="detailBody"></div>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script type="module">
import mountains from "./mountains.js";
import mountainsExtra from "./mountains_extra.js";
import { generateWeatherScore, geocodeMountain } from "./weather.js";
import { loadSetNames, GEO_OVERRIDES } from "./mountaimSets.js";

const timeSlots  = ["06:00","08:00","10:00","12:00","14:00","16:00"];
const timeLabels = ["06–08","08–10","10–12","12–14","14–16","16–18"];

const slider = document.getElementById("timeSlider");
const timeLabel = document.getElementById("timeLabel");
const daySelect = document.getElementById("day");
const setStatus = document.getElementById("setStatus");
const exportHint = document.getElementById("exportHint");

const buildBtn = document.getElementById("buildExtra");
const resetBtn = document.getElementById("resetBuild");

const BUILD_STATE_KEY = "mount_extra_build_state_v2_wiki_first";

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}
function setStatusHtml(lines){
  const safe = (lines || []).filter(Boolean).slice(0, 14).map(s => escapeHtml(s));
  setStatus.innerHTML = safe.join("<br>");
}
function pad2(n){ return String(n).padStart(2, "0"); }
function formatLocalYMD(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
function getDateKey(offset){
  const d = new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate() + offset);
  return formatLocalYMD(d);
}
const WDS = ["日","月","火","水","木","金","土"];
function getDateObj(offset){
  const d = new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate() + offset);
  return d;
}
function dayLabel(offset){
  const d = getDateObj(offset);
  const mm = pad2(d.getMonth()+1), dd = pad2(d.getDate()), wd = WDS[d.getDay()];
  const rel = offset === 0 ? "今日" : `${offset}日後`;
  return `${mm}/${dd}(${wd}) ${rel}`;
}
function initDaySelectLabels(){ [...daySelect.options].forEach(opt => opt.textContent = dayLabel(Number(opt.value))); }

function nearestTimeSlotIndexNow(){
  const now = new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();
  const starts = timeSlots.map(s => Number(s.slice(0,2)) * 60);
  let bestIdx = 0, bestDiff = Infinity;
  starts.forEach((min, idx) => { const diff = Math.abs(nowMin - min); if (diff < bestDiff){ bestDiff = diff; bestIdx = idx; } });
  if (nowMin < starts[0]) return 0;
  if (nowMin > starts[starts.length - 1] + 120) return starts.length - 1;
  return bestIdx;
}
function setSliderIndex(idx){
  slider.value = String(idx);
  timeLabel.textContent = timeLabels[idx];
}
slider.oninput = () => { timeLabel.textContent = timeLabels[Number(slider.value)]; updateView(); };
daySelect.addEventListener("change", () => { if (Number(daySelect.value)===0) setSliderIndex(nearestTimeSlotIndexNow()); updateView(); });
const getSelectedTime = () => timeSlots[Number(slider.value)];

function setLabel(k){
  return ({
    HYAKU:"百名山",
    HANA_100:"花100",
    NIHON_200:"二百名山",
    NIHON_300:"三百名山"
  }[k] ?? k);
}
function normName(s){
  return String(s ?? "").trim().replace(/\s+/g,"").replace(/[（(].*?[）)]/g,"");
}

/* ===== 日本bbox（ざっくり） ===== */
function isInJapanBbox(lat, lng){
  // 北海道～沖縄を包含（ざっくり安全側）
  return (lat >= 24.0 && lat <= 46.5 && lng >= 123.0 && lng <= 146.5);
}
function isValidCoord(lat, lng){
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return false;
  if (lat === 0 && lng === 0) return false;
  return isInJapanBbox(lat, lng);
}

/* ===== Wikipedia Coordinates API（最優先） ===== */
async function wikiCoords(title){
  // MediaWiki API（CORS回避の origin=*）
  // タイトルはそのまま渡す（redirect対応のため redirects=1）
  const url = "https://ja.wikipedia.org/w/api.php"
    + "?action=query&format=json&origin=*"
    + "&prop=coordinates&colimit=1&coprop=type"
    + "&redirects=1&titles=" + encodeURIComponent(title);

  const res = await fetch(url);
  if (!res.ok) return null;
  const data = await res.json();
  const pages = data?.query?.pages;
  if (!pages) return null;
  const first = Object.values(pages)[0];
  const c = first?.coordinates?.[0];
  if (!c) return null;
  const lat = Number(c.lat);
  const lng = Number(c.lon);
  if (!isValidCoord(lat, lng)) return null;
  return { lat, lng, source: "wiki" };
}

/* ===== 山名ゆらぎ候補 ===== */
function buildNameVariants(name){
  const base = String(name ?? "").trim();
  const clean = base.replace(/[（(].*?[）)]/g, "").trim();
  const variants = new Set([base, clean]);

  // 末尾が「山/岳/峰」じゃない場合は足す
  if (!/[山岳峰]$/.test(clean)){
    variants.add(clean + "山");
    variants.add(clean + "岳");
    variants.add(clean + "峰");
  }

  // 「○○ヶ岳」「○○ケ岳」「○○ガ岳」揺れ
  variants.add(clean.replace(/ヶ/g,"ケ"));
  variants.add(clean.replace(/ヶ/g,"ガ"));
  variants.add(clean.replace(/ケ/g,"ヶ"));
  variants.add(clean.replace(/ガ/g,"ヶ"));

  // 余計に曖昧な地名系は最後に回す（峠/沼/高原/湿原 などは山座標じゃない可能性）
  return [...variants].filter(Boolean);
}

function looksNonPeak(name){
  return /(沼|峠|高原|湿原|湖|池|原|ヶ原|平|谷|渓谷)$/u.test(String(name ?? ""));
}

/* ===== 既存データ統合（百名山＋extra） ===== */
const byName = new Map();
function upsertMountain(base){
  const key = normName(base.name);
  if (!key) return null;

  const sets = new Set(base._sets ?? []);
  if (!byName.has(key)){
    byName.set(key, {
      name: base.name,
      lat: base.lat ?? null,
      lng: base.lng ?? null,
      elev: base.elev ?? null,
      level: base.level ?? "中級",
      gpx: base.gpx ?? null,
      weather: base.weather ?? {},
      _sets: sets
    });
  }else{
    const m = byName.get(key);
    if (m.lat == null && base.lat != null) m.lat = base.lat;
    if (m.lng == null && base.lng != null) m.lng = base.lng;
    if (m.elev == null && base.elev != null) m.elev = base.elev;
    if (!m.level && base.level) m.level = base.level;
    if (!m.gpx && base.gpx) m.gpx = base.gpx;
    sets.forEach(s => m._sets.add(s));
  }
  return byName.get(key);
}
mountains.forEach(m => upsertMountain({ ...m, _sets:["HYAKU"] }));
(mountainsExtra || []).forEach(m => upsertMountain({ ...m, _sets:Array.isArray(m._sets) ? m._sets : [] }));

/* ===== 地図 ===== */
const map = L.map("map").setView([36.5, 138], 5);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
  { opacity: 0.5, attribution:"地理院 陰影" }
).addTo(map);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
  { opacity: 0.85, attribution:"地理院 地図" }
).addTo(map);

const markerLayer = L.layerGroup().addTo(map);

const icon = color => L.icon({
  iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
  shadowUrl: "https://unpkg.com/leaflet/dist/images/marker-shadow.png", // ←ここが unpkg.com
  iconSize: [25,41],
  iconAnchor: [12,41]
});

const icons = { A:icon("green"), B:icon("yellow"), C:icon("red") };
const scorePriority = { A:3, B:2, C:1 };

function getBestTime(weather, dateKey){
  const w = weather?.[dateKey];
  if (!w) return null;
  let best = null;
  for (const t of timeSlots) {
    const s = w[t];
    if (!s) continue;
    if (!best || scorePriority[s] > scorePriority[best.score]) best = { time:t, score:s };
  }
  return best;
}

/* ===== マーカー ===== */
const markerEntries = [];
const markerByKey = new Map();
function addMarkerForMountain(m){
  const key = normName(m.name);
  if (!key || markerByKey.has(key)) return;
  if (m.lat == null || m.lng == null) return;

  const marker = L.marker([m.lat, m.lng], { icon: icons["C"] });
  marker.on("click", () => map.setView([m.lat, m.lng], Math.max(map.getZoom(), 10)));

  markerEntries.push({ m, marker, shown:false });
  markerByKey.set(key, marker);
}

function getState(){
  const day = Number(daySelect.value);
  const time = getSelectedTime();
  const dateKey = getDateKey(day);
  const goodOnly = document.getElementById("goodOnly").checked;

  const scores = [...document.querySelectorAll(
    'input[value="A"]:checked,input[value="B"]:checked,input[value="C"]:checked'
  )].map(e => e.value);

  const levels = [...document.querySelectorAll(
    'input[value="初級"]:checked,input[value="中級"]:checked,input[value="上級"]:checked'
  )].map(e => e.value);

  const sets = [...document.querySelectorAll('.setChk:checked')].map(e => e.value);
  return { day, time, dateKey, goodOnly, scores, levels, sets };
}
function mountainInSelectedSets(m, sets){
  if (!sets?.length) return true;
  const ms = m._sets;
  if (!ms || ms.size === 0) return false;
  return sets.some(s => ms.has(s));
}

const listEl = document.getElementById("list");
const listBodyEl = document.getElementById("listBody");
function isMobile(){ return window.matchMedia && window.matchMedia("(max-width:768px)").matches; }

function drawList(items){
  const target = isMobile() ? listBodyEl : listEl;
  target.innerHTML = "";
  items.forEach(({ m, best }) => {
    const div = document.createElement("div");
    div.className = "list-item";
    div.innerHTML = `
      <b>${escapeHtml(m.name)}</b>
      ${best?.score==="A" ? "<span class='star'>★</span>" : ""}
      <br>
      標高:${m.elev ?? "-"}m / ${escapeHtml(m.level)}<br>
      ベスト:${best ? `${best.time}（${best.score}）` : "-"}
    `;
    div.onclick = () => map.setView([m.lat, m.lng], 11);
    target.appendChild(div);
  });
}

function updateView(){
  const { day, time, dateKey, goodOnly, scores, levels, sets } = getState();
  const items = [];

  for (const entry of markerEntries){
    const m = entry.m;
    const marker = entry.marker;

    const score = m.weather?.[dateKey]?.[time];
    const pass =
      !!score &&
      scores.includes(score) &&
      levels.includes(m.level) &&
      mountainInSelectedSets(m, sets) &&
      !(goodOnly && (score !== "A" || m.level === "上級"));

    if (pass){
      if (!entry.shown){
        markerLayer.addLayer(marker);
        entry.shown = true;
      }
      marker.setIcon(icons[score]);
      items.push({ m, best: getBestTime(m.weather, dateKey) });
    }else{
      if (entry.shown){
        markerLayer.removeLayer(marker);
        entry.shown = false;
      }
    }
  }

  drawList(items);
  setTimeout(() => map.invalidateSize(), 60);
}

/* ===== 生成進捗 ===== */
function loadBuildState(){
  try{
    const raw = localStorage.getItem(BUILD_STATE_KEY);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    obj.done = obj.done || {};
    obj.ng = obj.ng || {};
    return obj;
  }catch{
    return null;
  }
}
function saveBuildState(st){
  try{ localStorage.setItem(BUILD_STATE_KEY, JSON.stringify(st)); }catch{}
}
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function buildSetTargets(){
  const selected = [...document.querySelectorAll(".setChk:checked")].map(e => e.value);
  const targets = selected.filter(k => k !== "HYAKU");
  return targets.length ? targets : ["HANA_100","NIHON_200","NIHON_300"];
}

function mergeSetMembership(map, name, setKey){
  const key = normName(name);
  if (!key) return;
  if (!map.has(key)){
    map.set(key, { name, _sets: new Set([setKey]) });
  }else{
    map.get(key)._sets.add(setKey);
  }
}

function downloadText(filename, text){
  const blob = new Blob([text], { type:"text/javascript;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function copyOrDownload(filename, content, okMsg){
  try{
    await navigator.clipboard.writeText(content);
    exportHint.className = "chip ok";
    exportHint.style.display = "inline-block";
    exportHint.textContent = okMsg + "（クリップボード）";
    setTimeout(() => { exportHint.style.display="none"; }, 6000);
  }catch{
    exportHint.className = "chip danger";
    exportHint.style.display = "inline-block";
    exportHint.textContent = okMsg + "（コピー不可→ダウンロード）";
    downloadText(filename, content);
    setTimeout(() => { exportHint.style.display="none"; }, 7000);
  }
}

/* ===== ここが改善ポイント：Wiki→geocode、かつ誤爆除外 ===== */
async function resolveCoordsSmart(name){
  // 1) Wiki（最優先）
  const variants = buildNameVariants(name);

  // 山じゃなさそう（沼/峠/高原 etc）は、まずWikiだけ試してダメならNGに寄せる（誤爆防止）
  const nonPeak = looksNonPeak(name);

  for (const v of variants){
    const w = await wikiCoords(v);
    if (w) return w;
    await sleep(80);
  }

  if (nonPeak) return null;

  // 2) Open-Meteo geocode（保険）
  for (const v of variants){
    try{
      const g = await geocodeMountain(v);
      if (!g) continue;
      const lat = Number(g.lat);
      const lng = Number(g.lng);
      if (!isValidCoord(lat, lng)) continue;
      return { lat, lng, elev: (g.elev==null? null : Number(g.elev)), source:"geocode" };
    }catch{
      // try next
    }
    await sleep(120);
  }

  return null;
}

async function buildExtraOnce(){
  const targets = buildSetTargets();
  const metaLines = [];

  // 既存extra（座標が正しいものは最大限流用）
  const existing = new Map();
  (mountainsExtra || []).forEach(m => {
    const k = normName(m.name);
    if (!k) return;
    const lat = Number(m.lat), lng = Number(m.lng);
    if (isValidCoord(lat, lng)) existing.set(k, m);
  });

  // 百名山の集合（生成対象から除外）
  const hyakuSet = new Set(mountains.map(m => normName(m.name)));

  // 1) Wikipediaリストから山名取得（セットごと）
  const nameToSets = new Map();
  for (const setKey of targets){
    metaLines.push(`山名取得中: ${setLabel(setKey)} ...`);
    setStatusHtml(metaLines);

    const { names, meta } = await loadSetNames(setKey);
    metaLines.push(`  ${setLabel(setKey)}: ${names.length}件（${meta.cached ? "cache" : "fresh"}）`);
    setStatusHtml(metaLines);

    for (const n of names){
      // 百名山と被ってるなら除外（誤爆防止）
      if (hyakuSet.has(normName(n))) continue;
      mergeSetMembership(nameToSets, n, setKey);
    }
  }

  const namesAll = [...nameToSets.values()];
  const total = namesAll.length;

  let st = loadBuildState();
  if (!st || JSON.stringify(st.targets) !== JSON.stringify(targets)){
    st = { createdAt: new Date().toISOString(), targets, total, done:{}, ng:{} };
    saveBuildState(st);
  }else{
    st.total = total;
    saveBuildState(st);
  }

  let ok = 0, ng = 0;
  const start = Date.now();

  for (let i = 0; i < namesAll.length; i++){
    const item = namesAll[i];
    const key = normName(item.name);

    if (st.done[key] || st.ng[key]) continue;

    // 既存extraがあれば採用
    const ex = existing.get(key);
    if (ex){
      st.done[key] = {
        name: ex.name,
        lat: Number(ex.lat),
        lng: Number(ex.lng),
        elev: (ex.elev==null? null : Number(ex.elev)),
        _sets: Array.isArray(ex._sets) ? ex._sets : [...item._sets],
        source: "existing"
      };
      saveBuildState(st);
      continue;
    }

    // GEO_OVERRIDES が入っていれば採用（ただし日本内のみ）
    const ov = GEO_OVERRIDES?.[item.name];
    if (ov && isValidCoord(Number(ov.lat), Number(ov.lng))){
      st.done[key] = {
        name: item.name,
        lat: Number(ov.lat),
        lng: Number(ov.lng),
        elev: (ov.elev==null? null : Number(ov.elev)),
        _sets: [...item._sets],
        source: "override"
      };
      saveBuildState(st);
      continue;
    }

    metaLines.push(`座標取得 ${i+1}/${total}: ${item.name}`);
    setStatusHtml(metaLines.slice(-10));

    const r = await resolveCoordsSmart(item.name);
    if (!r){
      st.ng[key] = looksNonPeak(item.name) ? "non-peak word (lake/pass/plateau...)" : "not found";
      ng++;
      saveBuildState(st);
      continue;
    }

    st.done[key] = {
      name: item.name,
      lat: Number(r.lat),
      lng: Number(r.lng),
      elev: (r.elev==null? null : Number(r.elev)),
      _sets: [...item._sets],
      source: r.source
    };
    ok++;
    saveBuildState(st);

    await sleep(140);
  }

  const done = Object.values(st.done);

  // 2) 出力生成（日本内座標だけ）
  const out = done.map(r => ({
    name: r.name,
    lat: r.lat,
    lng: r.lng,
    elev: r.elev ?? null,
    level: "中級",
    gpx: null,
    weather: {},
    _sets: r._sets
  })).filter(x => isValidCoord(Number(x.lat), Number(x.lng)))
    .sort((a,b)=> String(a.name).localeCompare(String(b.name),"ja"));

  const elapsed = Math.round((Date.now() - start)/1000);
  const ngKeys = Object.keys(st.ng);

  setStatusHtml([
    `自動取得完了（対象セット: ${targets.map(setLabel).join(" / ")}）`,
    `OK: ${out.length} / NG: ${ngKeys.length} / 合計ユニーク: ${total}`,
    `所要: ${elapsed}s`,
    ngKeys.length ? `NG例: ${ngKeys.slice(0,10).join(" / ")}${ngKeys.length>10 ? " ..." : ""}` : "NGなし"
  ]);

  const content =
`// mountains_extra.js
// generated at: ${new Date().toISOString()}
// source: wikipedia coordinates first + open-meteo geocoding fallback
// note: level is temporary ("中級") for extra mountains.

const mountainsExtra = ${JSON.stringify(out, null, 2)};

export default mountainsExtra;
`;

  await copyOrDownload("mountains_extra.js", content, `生成完了: ${out.length}件（コピー or DL）`);
}

buildBtn.addEventListener("click", async () => {
  buildBtn.disabled = true;
  try{ await buildExtraOnce(); }
  finally{ buildBtn.disabled = false; }
});

resetBtn.addEventListener("click", () => {
  localStorage.removeItem(BUILD_STATE_KEY);
  exportHint.className = "chip";
  exportHint.style.display = "inline-block";
  exportHint.textContent = "生成進捗をリセットしました";
  setTimeout(() => { exportHint.style.display="none"; }, 3000);
});

/* ===== 初期化（固定データ表示は従来どおり高速） ===== */
async function init(){
  initDaySelectLabels();
  if (Number(daySelect.value) === 0) setSliderIndex(nearestTimeSlotIndexNow());

  const all = [...byName.values()];
  const geoOK = all.filter(m => Number.isFinite(m.lat) && Number.isFinite(m.lng));

  setStatusHtml([
    `固定データ統合: 合計${all.length}件 / 座標あり${geoOK.length}件`,
    `※自動座標取得はボタン押下時のみ（通常利用は高速）`
  ]);

  for (const m of geoOK) addMarkerForMountain(m);

  await Promise.all(geoOK.map(async m => {
    if (!m.weather || Object.keys(m.weather).length === 0){
      m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
    }
  }));

  document.querySelectorAll("#control input,#control select").forEach(e => {
    if (e === daySelect) return;
    e.addEventListener("change", () => updateView());
  });

  updateView();
}
init();
</script>
</body>
</html>
