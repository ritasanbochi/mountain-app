<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ç™»å±±å‘ã‘å±±å²³ãƒãƒƒãƒ—</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<link rel="icon" href="data:,">

<style>
  body { margin:0; font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }

  #control{
    padding:10px;
    background:#f4f4f4;
    font-size:14px;
    display:flex;
    flex-wrap:wrap;
    gap:8px 10px;
    align-items:center;
  }
  #control b{ margin-right:4px; }
  #control label{ white-space:nowrap; }
  #control .group{
    display:flex;
    flex-wrap:wrap;
    gap:6px 10px;
    align-items:center;
    padding:4px 6px;
    border:1px solid #ddd;
    border-radius:10px;
    background:#fff;
  }

  .btn{
    appearance:none;
    border:1px solid #cfcfcf;
    background:#fff;
    padding:6px 10px;
    border-radius:10px;
    font-size:13px;
    cursor:pointer;
  }
  .btn:hover{ background:#f7f7f7; }
  .btn:active{ transform: translateY(1px); }
  .chip{
    display:inline-block;
    padding:1px 8px;
    border-radius:999px;
    background:#eef6ff;
    border:1px solid #b7d7ff;
    font-size:12px;
    margin-left:6px;
  }
  .chip.bad{ background:#fff0f0; border-color:#e0a3a3; }

  #container{ height:calc(100vh - 120px); position:relative; }
  #map{ height:100%; width:100%; }

  #list{
    position:absolute;
    top:0; right:0;
    width:320px; height:100%;
    overflow-y:auto;
    background:#fff;
    border-left:1px solid #ccc;
    font-size:13px;
    z-index:1000;
  }
  .list-item{
    border-bottom:1px solid #ddd;
    padding:8px;
    cursor:pointer;
  }
  .list-item:hover{ background:#eef6ff; }

  .star{ color:gold; font-weight:bold; }

  .badge{
    display:inline-block;
    padding:1px 6px;
    border-radius:10px;
    font-size:11px;
    margin-left:6px;
    vertical-align:1px;
  }
  .badge-api{ background:#e7f7ea; border:1px solid #9ad3a5; }
  .badge-dummy{ background:#fff0f0; border:1px solid #e0a3a3; }

  .setpill{
    display:inline-block;
    padding:1px 6px;
    border-radius:999px;
    font-size:11px;
    border:1px solid #ddd;
    background:#fafafa;
    margin-left:6px;
  }

  hr{ border:none; border-top:1px solid #ddd; margin:8px 0; }
  small{ color:#555; }

  /* ===== detail overlay ===== */
  #detailOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.35);
    z-index:9999;
    display:none;
  }
  #detailOverlay.show{ display:block; }

  #detailPanel{
    position:absolute;
    inset:0;
    background:#fff;
    display:flex;
    flex-direction:column;
  }
  #detailHeader{
    position:sticky;
    top:0;
    background:#fff;
    border-bottom:1px solid #ddd;
    padding:10px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  #detailHeader b{
    font-size:16px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    max-width:70%;
  }
  #detailClose{
    appearance:none;
    border:1px solid #ccc;
    background:#f7f7f7;
    padding:6px 10px;
    border-radius:8px;
    font-size:14px;
  }
  #detailBody{
    padding:12px;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    line-height:1.5;
  }

  @media (min-width:769px){
    #detailPanel{
      inset:auto;
      top:24px; left:50%;
      transform:translateX(-50%);
      width:min(980px, calc(100vw - 48px));
      height:min(86vh, 900px);
      border-radius:14px;
      box-shadow:0 14px 40px rgba(0,0,0,0.24);
    }
  }

  .wx-table{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  .wx-table th, .wx-table td{
    border:1px solid #ddd;
    padding:4px 6px;
    text-align:center;
  }
  .wx-table th{
    background:#f7f7f7;
    font-weight:600;
  }
  .wx-current{ background:#eef6ff; font-weight:700; }

  .score-grid{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  .score-grid td, .score-grid th{
    border:1px solid #ddd;
    padding:4px 0;
    text-align:center;
  }
  .score-grid th{ background:#f7f7f7; font-weight:600; }
  .score-grid .sel{
    outline:2px solid #5aa7ff;
    outline-offset:-2px;
    font-weight:800;
    background:#eef6ff;
  }
  .score-grid .a{ background:#eaf7ee; }
  .score-grid .b{ background:#fff7db; }
  .score-grid .c{ background:#ffe7e7; }

  /* ===== mobile list ===== */
  #listHeader{ display:none; }
  #listTab{ display:none; }

  @media (max-width:768px){
    #list{
      position:fixed;
      left:0; right:0;
      bottom:0; top:auto;
      width:100%;
      height:45vh;
      border-left:none;
      border-top:1px solid #ccc;
      border-radius:14px 14px 0 0;
      box-shadow: 0 -6px 18px rgba(0,0,0,0.08);
      overflow:hidden;
      z-index:2000;
      transform: translateY(0);
      transition: transform 220ms ease;
      touch-action: pan-y;
      background:#fff;
    }
    #list.is-collapsed{ transform: translateY(100%); }

    #listHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      background:#fff;
      border-bottom:1px solid #eee;
      user-select:none;
    }
    #listHeader .title{ font-weight:700; font-size:14px; }
    #listHeader .grip{
      width:42px; height:5px;
      border-radius:999px;
      background:#d8d8d8;
      margin:0 10px;
    }
    #listHeader .hint{
      font-size:12px;
      color:#666;
      white-space:nowrap;
    }

    #listBody{
      height:calc(45vh - 48px);
      overflow:auto;
      -webkit-overflow-scrolling:touch;
    }

    #listTab{
      display:block;
      position:fixed;
      left:12px;
      bottom:12px;
      z-index:2500;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid #cfcfcf;
      background:#fff;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      font-size:13px;
    }
    #listTab.hidden{ display:none; }
  }

  /* ===== coord editor overlay (ä¿é™º) ===== */
  #coordOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.35);
    z-index:9998;
    display:none;
  }
  #coordOverlay.show{ display:block; }

  #coordPanel{
    position:absolute;
    inset:0;
    background:#fff;
    display:flex;
    flex-direction:column;
  }
  #coordHeader{
    position:sticky;
    top:0;
    background:#fff;
    border-bottom:1px solid #ddd;
    padding:10px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  #coordHeader b{ font-size:16px; }
  #coordClose{
    appearance:none;
    border:1px solid #ccc;
    background:#f7f7f7;
    padding:6px 10px;
    border-radius:8px;
    font-size:14px;
  }
  #coordBody{
    padding:12px;
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    line-height:1.4;
  }
  @media (min-width:769px){
    #coordPanel{
      inset:auto;
      top:24px; left:50%;
      transform:translateX(-50%);
      width:min(980px, calc(100vw - 48px));
      height:min(86vh, 900px);
      border-radius:14px;
      box-shadow:0 14px 40px rgba(0,0,0,0.24);
    }
  }

  .coord-grid{
    display:grid;
    grid-template-columns: 1.2fr 1fr;
    gap:12px;
  }
  @media (max-width:900px){
    .coord-grid{ grid-template-columns: 1fr; }
  }

  .card{
    border:1px solid #ddd;
    border-radius:12px;
    padding:10px;
    background:#fff;
  }
  .card h3{
    margin:0 0 6px 0;
    font-size:14px;
  }
  .coord-list{
    max-height: 52vh;
    overflow:auto;
    border:1px solid #eee;
    border-radius:10px;
  }
  .coord-item{
    padding:8px 10px;
    border-bottom:1px solid #eee;
    cursor:pointer;
  }
  .coord-item:hover{ background:#f7fbff; }
  .coord-item.active{ background:#eef6ff; font-weight:700; }

  .form-row{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    margin:8px 0;
  }
  .form-row label{
    font-size:12px;
    color:#333;
    display:flex;
    flex-direction:column;
    gap:4px;
    min-width: 160px;
  }
  .form-row input, .form-row textarea{
    border:1px solid #ccc;
    border-radius:10px;
    padding:8px 10px;
    font-size:13px;
  }
  .form-row textarea{ width:100%; min-height:70px; }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
</style>
</head>

<body>
<div id="control">
  <div class="group">
    <b>æ—¥ä»˜</b>
    <select id="day">
      <option value="0">ä»Šæ—¥</option>
      <option value="1">1æ—¥å¾Œ</option>
      <option value="2">2æ—¥å¾Œ</option>
      <option value="3">3æ—¥å¾Œ</option>
    </select>

    <b>æ™‚é–“å¸¯</b>
    <input type="range" id="timeSlider" min="0" max="5" value="0">
    <span id="timeLabel">06â€“08</span>
  </div>

  <div class="group">
    <b>å±±ã‚»ãƒƒãƒˆ</b>
    <label><input type="checkbox" class="setChk" value="HYAKU" checked>ç™¾åå±±</label>
    <label><input type="checkbox" class="setChk" value="HANA_100">èŠ±ã®ç™¾åå±±</label>
    <label><input type="checkbox" class="setChk" value="NIHON_200">äºŒç™¾åå±±</label>
    <label><input type="checkbox" class="setChk" value="NIHON_300">ä¸‰ç™¾åå±±</label>
  </div>

  <div class="group">
    <b>å¤©æ°—</b>
    <label><input type="checkbox" value="A" checked>A</label>
    <label><input type="checkbox" value="B" checked>B</label>
    <label><input type="checkbox" value="C" checked>C</label>
  </div>

  <div class="group">
    <b>é›£æ˜“åº¦</b>
    <label><input type="checkbox" value="åˆç´š" checked>åˆç´š</label>
    <label><input type="checkbox" value="ä¸­ç´š" checked>ä¸­ç´š</label>
    <label><input type="checkbox" value="ä¸Šç´š" checked>ä¸Šç´š</label>
    <label style="margin-left:6px;"><input type="checkbox" id="goodOnly"> ç™»ã‚Œã‚‹å±±ã ã‘</label>
  </div>

  <div class="group">
    <button id="openCoord" class="btn" type="button">åº§æ¨™ä¿®æ­£</button>
    <span id="coordCount" class="chip bad" style="display:none;"></span>
  </div>

  <div class="group">
    <span id="setStatus" style="font-size:12px;color:#444; max-width: 72vw;"></span>
  </div>
</div>

<div id="container">
  <div id="map"></div>

  <div id="list">
    <div id="listHeader">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="grip" aria-hidden="true"></div>
        <div class="title">å±±ãƒªã‚¹ãƒˆ</div>
      </div>
      <div class="hint">ä¸‹ã¸ã‚¹ãƒ¯ã‚¤ãƒ— / ã‚¿ãƒƒãƒ—ã§éš ã™</div>
    </div>
    <div id="listBody"></div>
  </div>
</div>

<button id="listTab" class="hidden" type="button">å±±ãƒªã‚¹ãƒˆ</button>

<!-- Detail overlay -->
<div id="detailOverlay" aria-hidden="true">
  <div id="detailPanel" role="dialog" aria-modal="true" aria-label="å±±ã®è©³ç´°">
    <div id="detailHeader">
      <b id="detailTitle">å±±ã®è©³ç´°</b>
      <button id="detailClose" type="button">é–‰ã˜ã‚‹</button>
    </div>
    <div id="detailBody"></div>
  </div>
</div>

<!-- Coord editor overlay -->
<div id="coordOverlay" aria-hidden="true">
  <div id="coordPanel" role="dialog" aria-modal="true" aria-label="åº§æ¨™ä¿®æ­£">
    <div id="coordHeader">
      <b>åº§æ¨™ä¿®æ­£ï¼ˆæœ€å°é™ã®ä¿é™ºï¼‰</b>
      <button id="coordClose" type="button">é–‰ã˜ã‚‹</button>
    </div>
    <div id="coordBody">
      <div class="coord-grid">
        <div class="card">
          <h3>åº§æ¨™æœªè§£æ±ºãƒªã‚¹ãƒˆ</h3>
          <div class="form-row">
            <label style="min-width:260px;">
              çµã‚Šè¾¼ã¿ï¼ˆå±±åï¼‰
              <input id="coordFilter" type="text" placeholder="ä¾‹: å¥¥å¤šæ‘© / ä¸‰é ­å±± ãªã©">
            </label>
            <button id="refreshCoordList" class="btn" type="button">æ›´æ–°</button>
          </div>
          <div id="coordList" class="coord-list"></div>
          <small>â€» åŸå‰‡ã¯è‡ªå‹•ã§åŸ‹ã¾ã‚‹æƒ³å®šã€‚ã©ã†ã—ã¦ã‚‚æ®‹ã£ãŸæ™‚ã ã‘ã“ã“ã‚’ä½¿ã†ã€‚</small>
        </div>

        <div class="card">
          <h3>é¸æŠä¸­ã®å±±</h3>
          <div id="coordSelected" class="mono" style="margin-bottom:8px;">ï¼ˆæœªé¸æŠï¼‰</div>

          <div class="form-row">
            <label>
              ç·¯åº¦ï¼ˆlatï¼‰
              <input id="inLat" type="number" step="0.000001" placeholder="ä¾‹: 35.123456">
            </label>
            <label>
              çµŒåº¦ï¼ˆlngï¼‰
              <input id="inLng" type="number" step="0.000001" placeholder="ä¾‹: 139.123456">
            </label>
            <label>
              æ¨™é«˜ï¼ˆm / ä»»æ„ï¼‰
              <input id="inElev" type="number" step="1" placeholder="ä¾‹: 1531">
            </label>
          </div>

          <div class="form-row" style="align-items:flex-start;">
            <label style="min-width:100%;">
              ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰
              <textarea id="inNote" placeholder="ä¾‹: å¥¥å¤šæ‘©ã®ä¸‰é ­å±±ï¼ˆéƒ½æ°‘ã®æ£®ä»˜è¿‘ï¼‰"></textarea>
            </label>
          </div>

          <div class="form-row">
            <button id="saveOverride" class="btn" type="button">ä¿å­˜</button>
            <button id="deleteOverride" class="btn" type="button">å‰Šé™¤</button>
            <button id="zoomTo" class="btn" type="button">åœ°å›³ã¸ã‚ºãƒ¼ãƒ </button>
          </div>

          <hr>

          <h3>JSONï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—/ç§»è¡Œï¼‰</h3>
          <div class="form-row" style="align-items:flex-start;">
            <label style="min-width:100%;">
              Export / Import
              <textarea id="overrideJson" class="mono" placeholder="ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ / ã“ã“ã«è²¼ã£ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"></textarea>
            </label>
          </div>
          <div class="form-row">
            <button id="exportOverrides" class="btn" type="button">Export</button>
            <button id="importOverrides" class="btn" type="button">Import</button>
            <button id="clearOverrides" class="btn" type="button">å…¨æ¶ˆå»</button>
          </div>

          <small>
            åº§æ¨™å…¥åŠ›å…ƒãŠã™ã™ã‚ï¼šå›½åœŸåœ°ç†é™¢åœ°å›³ / YAMAP / ãƒ¤ãƒãƒ¬ã‚³ã€‚å±±é ‚ã‚¯ãƒªãƒƒã‚¯â†’ç·¯åº¦çµŒåº¦ï¼ˆ10é€²ï¼‰ã‚’ã‚³ãƒ”ãƒšã€‚
          </small>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script type="module">
import mountains from "./mountains.js";
import { loadSetNames, SET_DEFS, GEO_OVERRIDES } from "./mountaimSets.js";
import { generateWeatherScore } from "./weather.js";

/* ===== æ™‚é–“å¸¯ ===== */
const timeSlots  = ["06:00","08:00","10:00","12:00","14:00","16:00"];
const timeLabels = ["06â€“08","08â€“10","10â€“12","12â€“14","14â€“16","16â€“18"];

const slider = document.getElementById("timeSlider");
const timeLabel = document.getElementById("timeLabel");
const daySelect = document.getElementById("day");
const setStatus = document.getElementById("setStatus");

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}
function setStatusHtml(lines){
  const safe = (lines || []).filter(Boolean).slice(0, 9).map(s => escapeHtml(s));
  setStatus.innerHTML = safe.join("<br>");
}

function nearestTimeSlotIndexNow(){
  const now = new Date();
  const nowMin = now.getHours() * 60 + now.getMinutes();
  const starts = timeSlots.map(s => Number(s.slice(0,2)) * 60);
  let bestIdx = 0, bestDiff = Infinity;
  starts.forEach((min, idx) => {
    const diff = Math.abs(nowMin - min);
    if (diff < bestDiff) { bestDiff = diff; bestIdx = idx; }
  });
  if (nowMin < starts[0]) return 0;
  if (nowMin > starts[starts.length - 1] + 120) return starts.length - 1;
  return bestIdx;
}
function setSliderIndex(idx){
  slider.value = String(idx);
  timeLabel.textContent = timeLabels[idx];
}
slider.oninput = () => {
  timeLabel.textContent = timeLabels[Number(slider.value)];
  updateView();
};
const getSelectedTime = () => timeSlots[Number(slider.value)];

daySelect.addEventListener("change", () => {
  if (Number(daySelect.value) === 0) setSliderIndex(nearestTimeSlotIndexNow());
  updateView();
});

function pad2(n){ return String(n).padStart(2, "0"); }
function formatLocalYMD(d){
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}
function getDateKey(offset){
  const d = new Date();
  d.setHours(0,0,0,0);
  d.setDate(d.getDate() + offset);
  return formatLocalYMD(d);
}

const WDS = ["æ—¥","æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ"];
function getDateObj(offset){
  const d = new Date();
  d.setHours(0,0,0,0);
  d.setDate(d.getDate() + offset);
  return d;
}
function dayLabel(offset){
  const d = getDateObj(offset);
  const mm = pad2(d.getMonth()+1);
  const dd = pad2(d.getDate());
  const wd = WDS[d.getDay()];
  const rel = offset === 0 ? "ä»Šæ—¥" : `${offset}æ—¥å¾Œ`;
  return `${mm}/${dd}(${wd}) ${rel}`;
}
function initDaySelectLabels(){
  [...daySelect.options].forEach(opt => {
    const off = Number(opt.value);
    opt.textContent = dayLabel(off);
  });
}

/* ===== åœ°å›³ ===== */
const map = L.map("map").setView([36.5, 138], 5);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
  { opacity: 0.5, attribution:"åœ°ç†é™¢ é™°å½±" }
).addTo(map);
L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
  { opacity: 0.85, attribution:"åœ°ç†é™¢ åœ°å›³" }
).addTo(map);

const markerLayer = L.layerGroup().addTo(map);

/* ===== ã‚¢ã‚¤ã‚³ãƒ³ ===== */
const icon = color => L.icon({
  iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
  shadowUrl: "https://unpkg.com/leaflet/dist/images/marker-shadow.png",
  iconSize: [25,41],
  iconAnchor: [12,41]
});
const icons = { A:icon("green"), B:icon("yellow"), C:icon("red") };
const scorePriority = { A:3, B:2, C:1 };

/* ===== utils ===== */
function fmt(n, digits=1){
  if (n === null || n === undefined) return "-";
  const v = Number(n);
  return Number.isFinite(v) ? v.toFixed(digits) : "-";
}
function fmtJpDateTime(iso){
  if (!iso) return "-";
  const d = new Date(iso);
  if (!Number.isFinite(d.getTime())) return "-";
  return `${d.getFullYear()}/${pad2(d.getMonth()+1)}/${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
}
function timeAgo(iso){
  if (!iso) return "-";
  const t = new Date(iso).getTime();
  if (!Number.isFinite(t)) return "-";
  const sec = Math.floor((Date.now() - t) / 1000);
  if (sec < 60) return `${sec}så‰`;
  const min = Math.floor(sec / 60);
  if (min < 60) return `${min}åˆ†å‰`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `${hr}æ™‚é–“å‰`;
  const day = Math.floor(hr / 24);
  return `${day}æ—¥å‰`;
}
function getDetail(m, dateKey, time){
  return m.weather?._details?.[dateKey]?.[time] ?? null;
}
function getBestTime(weather, dateKey){
  const w = weather?.[dateKey];
  if (!w) return null;
  let best = null;
  for (const t of timeSlots) {
    const s = w[t];
    if (!s) continue;
    if (!best || scorePriority[s] > scorePriority[best.score]) best = { time:t, score:s };
  }
  return best;
}
function scoreCellClass(score){
  if (score === "A") return "a";
  if (score === "B") return "b";
  if (score === "C") return "c";
  return "";
}
function buildScoreGridHtml(m, selDay, selTime){
  const head = `
    <thead>
      <tr>
        <th style="width:18%"></th>
        ${timeLabels.map(l => `<th>${l}</th>`).join("")}
      </tr>
    </thead>
  `;
  const bodyRows = [];
  for (let d = 0; d <= 3; d++){
    const dk = getDateKey(d);
    const tds = timeSlots.map(t => {
      const s = m.weather?.[dk]?.[t] ?? "-";
      const base = scoreCellClass(s);
      const sel = (d === selDay && t === selTime) ? "sel" : "";
      return `<td class="${base} ${sel}">${s ?? "-"}</td>`;
    }).join("");
    bodyRows.push(`<tr><th>${escapeHtml(dayLabel(d))}</th>${tds}</tr>`);
  }
  return `
    <b>ã‚¹ã‚³ã‚¢æ—©è¦‹è¡¨ï¼ˆä»Šæ—¥ã€œ3æ—¥å¾Œ Ã— å…¨æ™‚é–“å¸¯ï¼‰</b><br>
    <table class="score-grid">
      ${head}
      <tbody>${bodyRows.join("")}</tbody>
    </table>
    <small>â€» é¸æŠä¸­ã®æ—¥ä»˜Ã—æ™‚é–“ã¯æ ç·šã§å¼·èª¿</small>
  `;
}

/* ===== ã‚»ãƒƒãƒˆè¡¨ç¤º ===== */
function setLabel(k){
  return ({
    HYAKU:"ç™¾åå±±",
    HANA_100:"èŠ±100",
    NIHON_200:"äºŒç™¾åå±±",
    NIHON_300:"ä¸‰ç™¾åå±±"
  }[k] ?? (SET_DEFS?.[k]?.label ?? k));
}
function normName(s){
  return String(s ?? "")
    .trim()
    .replace(/\s+/g,"")
    .replace(/[ï¼ˆ(].*?[ï¼‰)]/g,"");
}

/* ===== master ===== */
const byName = new Map();
function upsertMountain(base){
  const key = normName(base.name);
  if (!key) return null;
  if (!byName.has(key)){
    const m = { ...base, _sets: new Set(base._sets ?? []) };
    byName.set(key, m);
  }else{
    const m = byName.get(key);
    if (m.lat == null && base.lat != null) m.lat = base.lat;
    if (m.lng == null && base.lng != null) m.lng = base.lng;
    if (m.elev == null && base.elev != null) m.elev = base.elev;
    if (!m.level && base.level) m.level = base.level;
    (base._sets ?? []).forEach(s => m._sets.add(s));
  }
  return byName.get(key);
}
mountains.forEach(m => upsertMountain({ ...m, _sets:["HYAKU"] }));

/* ===== ã‚»ãƒƒãƒˆãƒ­ãƒ¼ãƒ‰ç®¡ç† ===== */
const loadedSetKeys = new Set();

/* ===== æ‰‹å‹•overrideï¼ˆlocalStorageï¼‰ ===== */
const MANUAL_OVR_KEY = "mount_geo_manual_overrides_v1";
function loadManualOverrides(){
  try{
    const obj = JSON.parse(localStorage.getItem(MANUAL_OVR_KEY) || "{}");
    return (obj && typeof obj === "object") ? obj : {};
  }catch{
    return {};
  }
}
function saveManualOverrides(obj){
  try{ localStorage.setItem(MANUAL_OVR_KEY, JSON.stringify(obj)); }catch{}
}
let manualOverrides = loadManualOverrides();

/* ===== Open-Meteo geocoding cache ===== */
const GEO_CACHE_KEY = "mount_geo_openmeteo_v2";
const geoCache = (() => { try { return JSON.parse(localStorage.getItem(GEO_CACHE_KEY)||"{}")||{}; } catch { return {}; } })();
function saveGeoCache(){ try { localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(geoCache)); } catch {} }

/* ===== Wikipedia batch coord cache ===== */
const WIKI_API = "https://ja.wikipedia.org/w/api.php";
const WIKI_COORD_CACHE_KEY = "mount_wiki_coord_cache_v2";
const wikiCoordCache = (() => {
  try { return JSON.parse(localStorage.getItem(WIKI_COORD_CACHE_KEY) || "{}") || {}; }
  catch { return {}; }
})();
function saveWikiCoordCache(){
  try { localStorage.setItem(WIKI_COORD_CACHE_KEY, JSON.stringify(wikiCoordCache)); } catch {}
}

function isJapanLike(lat,lng){
  return lat >= 24 && lat <= 46.5 && lng >= 122 && lng <= 146.5;
}

/* ===== Open-Meteo Geocoding ===== */
async function openMeteoGeocode(query){
  const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=10&language=ja&format=json`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`geocode ${res.status}`);
  const j = await res.json();
  const r = j?.results;
  if (!Array.isArray(r) || r.length === 0) return null;

  const jp = r.find(x => isJapanLike(Number(x.latitude), Number(x.longitude))) || r[0];
  const lat = Number(jp.latitude), lng = Number(jp.longitude);
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
  const elev = (jp.elevation != null && Number.isFinite(Number(jp.elevation))) ? Number(jp.elevation) : null;
  return { lat, lng, elev };
}

/* ===== Wikipedia coords: ã¾ã¨ã‚ã¦å–å¾— ===== */
function chunk(arr, size){
  const out = [];
  for (let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size));
  return out;
}

async function fetchWikiCoordsBatch(titles){
  // titles: string[]  (max 50 recommended)
  const filtered = (titles || []).map(t => String(t||"").trim()).filter(Boolean);
  if (!filtered.length) return new Map();

  const params = new URLSearchParams({
    action: "query",
    format: "json",
    origin: "*",
    redirects: "1",
    prop: "coordinates",
    colimit: "1",
    titles: filtered.join("|")
  });

  const url = `${WIKI_API}?${params.toString()}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`wiki batch ${res.status}`);
  const j = await res.json();
  const pages = j?.query?.pages;
  const map = new Map();
  if (!pages) return map;

  for (const p of Object.values(pages)){
    const title = p?.title;
    const c = p?.coordinates?.[0];
    if (!title || !c) continue;
    const lat = Number(c.lat);
    const lng = Number(c.lon);
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
    map.set(title, { lat, lng, elev: null, source: "wiki_batch" });
  }
  return map;
}

function buildTitleCandidates(name){
  const n = String(name || "").trim();
  const cands = [];
  cands.push(n);

  if (n.endsWith("å³ ")) cands.push(n.replace(/å³ $/, "å¶º"));

  // ãƒ¶/ã‚± ã‚†ã‚Œ
  cands.push(n.replace(/ã‚±/g, "ãƒ¶"));
  cands.push(n.replace(/ãƒ¶/g, "ã‚±"));

  // æœ«å°¾ãŒå±±ã£ã½ããªã„ãªã‚‰å±±ã‚’ä»˜ã‘ã‚‹
  if (!/[å±±å²³å³°å¶º]$/.test(n)) cands.push(n + "å±±");

  // æ›–æ˜§ã•å›é¿ã§ (æ—¥æœ¬)
  cands.push(n + " (æ—¥æœ¬)");

  // é‡è¤‡é™¤å»
  return [...new Set(cands)].filter(Boolean);
}

/* ===== å±±åç¾¤ã‚’ Wikipedia ã§ â€œãƒãƒƒãƒã§â€ è§£æ±º ===== */
async function resolveGeoManyByWiki(names){
  // names: string[]
  // æˆ»ã‚Š: Map<origName, {lat,lng,elev,source, wikiTitle?}>
  const result = new Map();
  const need = (names || []).map(n => String(n||"").trim()).filter(Boolean);
  if (!need.length) return result;

  // æ—¢ã«cacheã‚ã‚‹ã‚‚ã®ã¯å³è¿”ã—
  const still = [];
  for (const n of need){
    const k = normName(n);
    const cached = wikiCoordCache[k];
    if (cached?.lat != null && cached?.lng != null){
      result.set(n, { ...cached, source: "wiki_cache" });
    }else{
      still.push(n);
    }
  }
  if (!still.length) return result;

  // 1st pass: ãã®ã¾ã¾ã®ã‚¿ã‚¤ãƒˆãƒ«ã ã‘ã§ä¸€æ‹¬
  const pass1 = still.map(n => n);
  for (const part of chunk(pass1, 50)){
    let map;
    try{
      map = await fetchWikiCoordsBatch(part);
    }catch{
      map = new Map();
    }
    for (const orig of part){
      if (result.has(orig)) continue;
      // è¿”ã£ã¦ãã‚‹ã‚­ãƒ¼ã¯ â€œtitleâ€ ã ãŒ redirects ã§åå‰ãŒå¤‰ã‚ã£ã¦ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
      // ãªã®ã§ part å†…ã® â€œorigâ€ æ–‡å­—åˆ—ãã®ã‚‚ã®ãŒ hit ã™ã‚‹ã‚±ãƒ¼ã‚¹ã‚’å„ªå…ˆã™ã‚‹
      const direct = map.get(orig);
      if (direct){
        const k = normName(orig);
        wikiCoordCache[k] = { lat: direct.lat, lng: direct.lng, elev: null };
        result.set(orig, { ...direct, wikiTitle: orig });
      }
    }
    saveWikiCoordCache();
  }

  // 2nd pass: å€™è£œã‚¿ã‚¤ãƒˆãƒ«ã‚’å¢—ã‚„ã—ã¦ alias è§£æ±ºï¼ˆæ®‹ã‚Šã ã‘ï¼‰
  const remain = still.filter(n => !result.has(n));
  if (!remain.length) return result;

  // orig -> candidates
  const pairs = [];
  const allTitles = [];
  for (const orig of remain){
    const cands = buildTitleCandidates(orig);
    for (const t of cands){
      pairs.push([orig, t]);
      allTitles.push(t);
    }
  }

  // é‡è¤‡é™¤å»ï¼ˆã‚¿ã‚¤ãƒˆãƒ«å´ï¼‰
  const uniqTitles = [...new Set(allTitles)];

  // ã‚¿ã‚¤ãƒˆãƒ«â†’coord ã‚’ã¾ã¨ã‚ã¦å–ã‚‹
  const titleToCoord = new Map();
  for (const part of chunk(uniqTitles, 50)){
    let map;
    try{
      map = await fetchWikiCoordsBatch(part);
    }catch{
      map = new Map();
    }
    for (const [title, coord] of map.entries()){
      titleToCoord.set(title, coord);
    }
  }

  // orig ã«æœ€åˆã«ãƒ’ãƒƒãƒˆã—ãŸå€™è£œã‚’å‰²ã‚Šå½“ã¦
  for (const [orig, t] of pairs){
    if (result.has(orig)) continue;
    const coord = titleToCoord.get(t);
    if (!coord) continue;
    const k = normName(orig);
    wikiCoordCache[k] = { lat: coord.lat, lng: coord.lng, elev: null };
    result.set(orig, { ...coord, wikiTitle: t });
  }
  saveWikiCoordCache();

  return result;
}

/* ===== resolveGeoï¼ˆå˜ç™ºï¼šä¿é™ºï¼‰ ===== */
async function resolveGeoSingle(name){
  const key = normName(name);
  if (!key) return null;

  // â‘  æ‰‹å‹•overrideï¼ˆä¿é™ºï¼‰
  const mo = manualOverrides?.[key] || manualOverrides?.[name];
  if (mo?.lat != null && mo?.lng != null){
    return { lat:Number(mo.lat), lng:Number(mo.lng), elev:(mo.elev!=null?Number(mo.elev):null), source:"manual" };
  }

  // â‘¡ å›ºå®šoverrideï¼ˆmountaimSets.jsï¼‰
  const ov = GEO_OVERRIDES?.[name] || GEO_OVERRIDES?.[key];
  if (ov?.lat != null && ov?.lng != null){
    return { lat:Number(ov.lat), lng:Number(ov.lng), elev:(ov.elev!=null?Number(ov.elev):null), source:"override" };
  }

  // â‘¢ wiki cache
  const wc = wikiCoordCache?.[key];
  if (wc?.lat != null && wc?.lng != null) return { ...wc, source:"wiki_cache" };

  // â‘£ Open-Meteoï¼ˆæœ€å¾Œã®ä¿é™ºï¼‰
  if (geoCache[key]) return { ...geoCache[key], source:"cache" };

  const tries = [name, `${name} æ—¥æœ¬`, `${name} å±± æ—¥æœ¬`];
  for (const q of tries){
    try{
      const g = await openMeteoGeocode(q);
      if (g){
        geoCache[key] = { lat:g.lat, lng:g.lng, elev:g.elev };
        saveGeoCache();
        return { ...geoCache[key], source:"geocode" };
      }
    }catch{}
  }
  return null;
}

/* ===== ãƒãƒ¼ã‚«ãƒ¼ï¼ˆå†ç”ŸæˆNGï¼šæœªä½œæˆã ã‘è¿½åŠ ï¼‰ ===== */
const markerEntries = [];
const markerByKey = new Map();
function addMarkerForMountain(m){
  const key = normName(m.name);
  if (!key || markerByKey.has(key)) return;
  if (m.lat == null || m.lng == null) return;

  const marker = L.marker([m.lat, m.lng], { icon: icons["C"] });
  marker.on("click", () => {
    map.setView([m.lat, m.lng], Math.max(map.getZoom(), 10));
    openDetail(m, marker);
  });

  markerEntries.push({ m, marker, shown:false });
  markerByKey.set(key, marker);
}

/* ===== ãƒ•ã‚£ãƒ«ã‚¿ ===== */
function getState(){
  const day = Number(daySelect.value);
  const time = getSelectedTime();
  const dateKey = getDateKey(day);
  const goodOnly = document.getElementById("goodOnly").checked;

  const scores = [...document.querySelectorAll(
    'input[value="A"]:checked,input[value="B"]:checked,input[value="C"]:checked'
  )].map(e => e.value);

  const levels = [...document.querySelectorAll(
    'input[value="åˆç´š"]:checked,input[value="ä¸­ç´š"]:checked,input[value="ä¸Šç´š"]:checked'
  )].map(e => e.value);

  const sets = [...document.querySelectorAll('.setChk:checked')].map(e => e.value);
  return { day, time, dateKey, goodOnly, scores, levels, sets };
}
function mountainInSelectedSets(m, sets){
  if (!sets?.length) return true;
  const ms = m._sets;
  if (!ms || ms.size === 0) return false;
  return sets.some(s => ms.has(s));
}

/* ===== ã‚»ãƒƒãƒˆï¼ˆå±±åï¼‰æŠ•å…¥ ===== */
async function ensureSetLoaded(setKey){
  if (setKey === "HYAKU") return;
  if (loadedSetKeys.has(setKey)) return;
  if (!SET_DEFS?.[setKey]) return;

  setStatusHtml([`${setLabel(setKey)}: å±±åå–å¾—ä¸­...`]);
  const { names, meta } = await loadSetNames(setKey);

  for (const name of names){
    const key = normName(name);
    if (!key) continue;

    if (byName.has(key)){
      byName.get(key)._sets.add(setKey);
      continue;
    }
    byName.set(key, {
      name,
      lat:null, lng:null, elev:null,
      level:"ä¸­ç´š",
      gpx:null,
      weather:{},
      _sets: new Set([setKey]),
      _setMeta: meta
    });
  }

  loadedSetKeys.add(setKey);
  setStatusHtml([`âœ… ${setLabel(setKey)} ãƒ­ãƒ¼ãƒ‰å®Œäº†: ${names.length}ä»¶ï¼ˆ${meta?.cached ? "cache" : "fresh"}ï¼‰`]);
}

/* ===== åº§æ¨™NGã‚’æºœã‚ã‚‹ï¼ˆä¿é™ºUIç”¨ï¼‰ ===== */
const pendingGeoSet = new Set(); // normName
function addPendingGeoName(name){
  const k = normName(name);
  if (!k) return;
  if (manualOverrides?.[k]?.lat != null && manualOverrides?.[k]?.lng != null) return;
  pendingGeoSet.add(k);
  refreshCoordBadge();
}
function refreshCoordBadge(){
  const chip = document.getElementById("coordCount");
  const count = pendingGeoSet.size;
  if (count > 0){
    chip.style.display = "inline-block";
    chip.textContent = `åº§æ¨™æœªè§£æ±º ${count}`;
  }else{
    chip.style.display = "none";
  }
}

/* ===== è¿½åŠ å‡¦ç†ï¼ˆåº§æ¨™â†’å¤©æ°—â†’ãƒãƒ¼ã‚«ãƒ¼ï¼‰ + ãƒ‡ãƒãƒƒã‚° ===== */
let resolving = false;
async function resolveForEnabledSets(){
  if (resolving) return;

  const { sets } = getState();
  if (!sets.length) return;

  const pending = [];
  for (const m of byName.values()){
    if (!mountainInSelectedSets(m, sets)) continue;
    const hasGeo = (m.lat != null && m.lng != null);
    const hasWx = (m.weather && Object.keys(m.weather).length);
    if (hasGeo && hasWx) continue;
    pending.push(m);
  }
  if (!pending.length){
    setStatusHtml([`è¿½åŠ å‡¦ç†: å¯¾è±¡ãªã—ï¼ˆã™ã¹ã¦è§£æ±ºæ¸ˆï¼‰`]);
    return;
  }

  resolving = true;
  let okGeo=0, ngGeo=0, okWx=0, ngWx=0;
  const ngNames = [];
  const batch = pending.slice(0, 40);

  setStatusHtml([
    `è¿½åŠ å‡¦ç†: ${batch.length}ä»¶ å®Ÿè¡Œä¸­...`,
    `ï¼ˆå¯¾è±¡æ®‹ã‚Š: ${pending.length}ä»¶ï¼‰`
  ]);

  // â˜… ã¾ãš â€œåº§æ¨™ãŒç„¡ã„â€ å±±ã ã‘é›†ã‚ã¦ Wikipedia ã‚’ãƒãƒƒãƒè§£æ±º
  const needGeo = batch.filter(m => m.lat == null || m.lng == null).map(m => m.name);
  let wikiResolved = new Map();
  try{
    wikiResolved = await resolveGeoManyByWiki(needGeo);
  }catch{
    wikiResolved = new Map();
  }

  for (const m of batch){
    try{
      if (m.lat == null || m.lng == null){
        const w = wikiResolved.get(m.name);
        if (w){
          m.lat = w.lat; m.lng = w.lng;
          okGeo++;
        }else{
          // ä¿é™ºã§å˜ç™ºè§£æ±ºï¼ˆoverride/manual/Open-Meteoï¼‰
          const g = await resolveGeoSingle(m.name);
          if (!g){
            ngGeo++;
            if (ngNames.length < 10) ngNames.push(m.name);
            addPendingGeoName(m.name);
            continue;
          }
          m.lat = g.lat; m.lng = g.lng;
          if (m.elev == null && g.elev != null) m.elev = Math.round(g.elev);
          okGeo++;
        }
      } else {
        okGeo++;
      }

      addMarkerForMountain(m);

      if (!m.weather || Object.keys(m.weather).length === 0){
        try{
          m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
          okWx++;
        }catch{
          ngWx++;
        }
      }
    }catch{
      ngGeo++;
      if (ngNames.length < 10) ngNames.push(m.name);
      addPendingGeoName(m.name);
    }
  }

  resolving = false;

  const remaining = pending.length - batch.length;
  const lines = [];
  lines.push(`è¿½åŠ å‡¦ç†: åº§æ¨™OK${okGeo}/NG${ngGeo} å¤©æ°—OK${okWx}/NG${ngWx}`);
  lines.push(`æ®‹ã‚Šï¼ˆæœªè§£æ±ºï¼‰: ${remaining}ä»¶ â€»ã‚‚ã†ä¸€åº¦æ“ä½œã§ç¶šãã‚’å‡¦ç†`);
  if (ngNames.length){
    lines.push(`åº§æ¨™NGä¾‹: ${ngNames.join(" / ")}`);
    lines.push(`ï¼ˆå¯¾ç­–: åŸå‰‡è‡ªå‹•ã€‚æ®‹ã£ãŸã‚‰åº§æ¨™ä¿®æ­£ã§æœ€å°é™ã ã‘æ‰‹å…¥åŠ›ï¼‰`);
  }
  setStatusHtml(lines);
}

/* ===== Detail ===== */
const detailOverlay = document.getElementById("detailOverlay");
const detailTitle = document.getElementById("detailTitle");
const detailBody = document.getElementById("detailBody");
const detailClose = document.getElementById("detailClose");
let currentDetail = null;

function detailHtml(m, selectedTime){
  const day = Number(daySelect.value);
  const dateKey = getDateKey(day);
  const grid = buildScoreGridHtml(m, day, selectedTime);

  const rows = timeSlots.map((t, idx) => {
    const s = m.weather?.[dateKey]?.[t] ?? "-";
    const d = getDetail(m, dateKey, t);
    const cls = (t === selectedTime) ? "wx-current" : "";
    return `
      <tr class="${cls}">
        <td>${timeLabels[idx]}</td>
        <td><b>${s ?? "-"}</b></td>
        <td>${d ? fmt(d.precipitation,1) : "-"}</td>
        <td>${d ? `${fmt(d.windspeed_mid,1)}â†’${fmt(d.windspeed_summit,1)}` : "-"}</td>
        <td>${d ? `${fmt(d.gust_mid,1)}â†’${fmt(d.gust_summit,1)}` : "-"}</td>
        <td>${d ? `${fmt(d.temp_mid,1)}â†’${fmt(d.temp_summit,1)}` : "-"}</td>
      </tr>
    `;
  }).join("");

  const setPills = m._sets?.size
    ? [...m._sets].map(s => `<span class="setpill">${escapeHtml(setLabel(s))}</span>`).join("")
    : "";

  return `
    <div class="popup">
      <b>${escapeHtml(m.name)}</b>${setPills}<br>
      æ¨™é«˜ï¼š${m.elev ?? "-"} m / é›£æ˜“åº¦ï¼š${escapeHtml(m.level)}<br>
      <small>åº§æ¨™: ${m.lat?.toFixed?.(5) ?? "-"}, ${m.lng?.toFixed?.(5) ?? "-"}</small>

      <hr>${grid}
      <hr>
      <b>${escapeHtml(dayLabel(day))} ã®æ ¹æ‹ ï¼ˆæ™‚é–“å¸¯åˆ¥ï¼‰</b><br>
      <table class="wx-table">
        <thead>
          <tr>
            <th>æ™‚é–“</th><th>ã‚¹ã‚³ã‚¢</th><th>é™æ°´(mm)</th><th>é¢¨(m/s)</th><th>çªé¢¨(m/s)</th><th>æ°—æ¸©(â„ƒ)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    </div>
  `;
}

function openDetail(m, marker){
  currentDetail = { mountain: m, marker };
  detailTitle.textContent = m.name;
  detailBody.innerHTML = detailHtml(m, getSelectedTime());
  detailOverlay.classList.add("show");
  detailOverlay.setAttribute("aria-hidden","false");
  document.body.style.overflow = "hidden";
}
function closeDetail(){
  detailOverlay.classList.remove("show");
  detailOverlay.setAttribute("aria-hidden","true");
  detailBody.innerHTML = "";
  document.body.style.overflow = "";
  currentDetail = null;
}
detailClose.onclick = closeDetail;
detailOverlay.addEventListener("click", (e) => {
  if (e.target === detailOverlay) closeDetail();
});
window.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && detailOverlay.classList.contains("show")) closeDetail();
});

/* ===== Mobile list ===== */
const listEl = document.getElementById("list");
const listHeaderEl = document.getElementById("listHeader");
const listBodyEl = document.getElementById("listBody");
const listTabEl = document.getElementById("listTab");

function isMobile(){ return window.matchMedia && window.matchMedia("(max-width:768px)").matches; }
let listCollapsed = false;
function setListCollapsed(v){
  listCollapsed = v;
  if (isMobile()){
    listEl.classList.toggle("is-collapsed", v);
    listTabEl.classList.toggle("hidden", !v);
  }else{
    listEl.classList.remove("is-collapsed");
    listTabEl.classList.add("hidden");
  }
}
function initMobileListGestures(){
  if (!isMobile()) return;
  listTabEl.onclick = () => setListCollapsed(false);

  let startY = 0, lastDy = 0, dragging = false;
  listHeaderEl.addEventListener("touchstart", (e) => {
    if (!e.touches?.length) return;
    startY = e.touches[0].clientY;
    lastDy = 0;
    dragging = true;
    listEl.style.transition = "none";
  }, { passive:true });

  listHeaderEl.addEventListener("touchmove", (e) => {
    if (!dragging || !e.touches?.length) return;
    const y = e.touches[0].clientY;
    const dy = Math.max(0, y - startY);
    lastDy = dy;
    listEl.style.transform = `translateY(${Math.min(dy, 260)}px)`;
  }, { passive:true });

  listHeaderEl.addEventListener("touchend", () => {
    if (!dragging) return;
    dragging = false;
    listEl.style.transition = "";
    listEl.style.transform = "";
    if (lastDy > 120) setListCollapsed(true);
  });

  window.addEventListener("resize", () => {
    setListCollapsed(isMobile() ? listCollapsed : false);
  });
}

/* ===== List render ===== */
function drawList(items, day){
  const target = isMobile() ? listBodyEl : listEl;

  if (isMobile()){
    target.innerHTML = `<div style="padding:8px 10px; font-weight:700;">${escapeHtml(dayLabel(day))} ã®å±±</div>`;
  } else {
    target.innerHTML = `<b>${escapeHtml(dayLabel(day))} ã®å±±</b><br>`;
  }

  items.forEach(({ m, best, marker }) => {
    const meta = m.weather?._meta || {};
    const isApiSrc = meta.source === "api";
    const badgeClass = isApiSrc ? "badge-api" : "badge-dummy";
    const srcText = isApiSrc ? "API" : "DUMMY";

    const setPills = m._sets?.size
      ? [...m._sets].map(s => `<span class="setpill">${escapeHtml(setLabel(s))}</span>`).join("")
      : "";

    const div = document.createElement("div");
    div.className = "list-item";
    div.innerHTML = `
      <b>${escapeHtml(m.name)}</b>
      ${best?.score==="A" ? "<span class='star'>â˜…</span>" : ""}
      <span class="badge ${badgeClass}">${srcText}</span>
      ${setPills}
      <br>
      æ¨™é«˜:${m.elev ?? "-"}m / ${escapeHtml(m.level)}<br>
      ãƒ™ã‚¹ãƒˆ:${best ? `${best.time}ï¼ˆ${best.score}ï¼‰` : "-"}<br>
      <small>å–å¾—:${fmtJpDateTime(meta.fetchedAt)}ï¼ˆ${timeAgo(meta.fetchedAt)}ï¼‰</small>
    `;
    div.onclick = () => {
      if (isMobile()) setListCollapsed(true);
      map.setView([m.lat, m.lng], 11);
      openDetail(m, marker);
    };
    target.appendChild(div);
  });
}

/* ===== update ===== */
function updateView(){
  const { day, time, dateKey, goodOnly, scores, levels, sets } = getState();
  const items = [];

  for (const entry of markerEntries){
    const m = entry.m;
    const marker = entry.marker;

    const score = m.weather?.[dateKey]?.[time];
    const pass =
      !!score &&
      scores.includes(score) &&
      levels.includes(m.level) &&
      mountainInSelectedSets(m, sets) &&
      !(goodOnly && (score !== "A" || m.level === "ä¸Šç´š"));

    if (pass){
      if (!entry.shown){
        markerLayer.addLayer(marker);
        entry.shown = true;
      }
      marker.setIcon(icons[score]);
      const best = getBestTime(m.weather, dateKey);
      items.push({ m, best, marker });
    }else{
      if (entry.shown){
        markerLayer.removeLayer(marker);
        entry.shown = false;
      }
      if (currentDetail?.mountain === m) closeDetail();
    }
  }

  drawList(items, day);

  if (currentDetail?.mountain){
    detailTitle.textContent = currentDetail.mountain.name;
    detailBody.innerHTML = detailHtml(currentDetail.mountain, time);
  }

  setTimeout(() => map.invalidateSize(), 60);
}

/* ===== åº§æ¨™ä¿®æ­£UIï¼ˆä¿é™ºï¼‰ ===== */
const coordOverlay = document.getElementById("coordOverlay");
const coordClose = document.getElementById("coordClose");
const openCoord = document.getElementById("openCoord");
const coordListEl = document.getElementById("coordList");
const coordFilterEl = document.getElementById("coordFilter");
const coordSelectedEl = document.getElementById("coordSelected");
const inLat = document.getElementById("inLat");
const inLng = document.getElementById("inLng");
const inElev = document.getElementById("inElev");
const inNote = document.getElementById("inNote");
const btnSave = document.getElementById("saveOverride");
const btnDelete = document.getElementById("deleteOverride");
const btnZoomTo = document.getElementById("zoomTo");
const btnRefreshCoordList = document.getElementById("refreshCoordList");
const taJson = document.getElementById("overrideJson");
const btnExport = document.getElementById("exportOverrides");
const btnImport = document.getElementById("importOverrides");
const btnClear = document.getElementById("clearOverrides");

let selectedCoordKey = null;

function openCoordPanel(){
  refreshCoordList();
  coordOverlay.classList.add("show");
  coordOverlay.setAttribute("aria-hidden","false");
  document.body.style.overflow = "hidden";
}
function closeCoordPanel(){
  coordOverlay.classList.remove("show");
  coordOverlay.setAttribute("aria-hidden","true");
  document.body.style.overflow = "";
}
openCoord.onclick = openCoordPanel;
coordClose.onclick = closeCoordPanel;
coordOverlay.addEventListener("click", (e) => {
  if (e.target === coordOverlay) closeCoordPanel();
});
window.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && coordOverlay.classList.contains("show")) closeCoordPanel();
});

function getUnresolvedNames(){
  const names = new Set([...pendingGeoSet]);
  const { sets } = getState();
  for (const m of byName.values()){
    if (!mountainInSelectedSets(m, sets)) continue;
    const k = normName(m.name);
    if (!k) continue;
    if (m.lat == null || m.lng == null){
      const mo = manualOverrides?.[k];
      if (!(mo?.lat != null && mo?.lng != null)) names.add(k);
    }
  }
  for (const k of Object.keys(manualOverrides || {})) names.add(k);
  return [...names].sort((a,b) => a.localeCompare(b, "ja"));
}

function refreshCoordList(){
  const q = (coordFilterEl.value || "").trim();
  const all = getUnresolvedNames();
  const filtered = q ? all.filter(n => n.includes(q)) : all;

  coordListEl.innerHTML = "";
  filtered.forEach(k => {
    const div = document.createElement("div");
    div.className = "coord-item" + (k === selectedCoordKey ? " active" : "");
    const mo = manualOverrides?.[k];
    const status = (mo?.lat != null && mo?.lng != null) ? "âœ…" : "âš ï¸";
    div.textContent = `${status} ${k}`;
    div.onclick = () => selectCoordKey(k);
    coordListEl.appendChild(div);
  });

  refreshCoordBadge();
}

function selectCoordKey(k){
  selectedCoordKey = k;
  const m = byName.get(k);
  const displayName = m?.name || k;

  const mo = manualOverrides?.[k] || {};
  coordSelectedEl.textContent = `å±±å: ${displayName}\nkey: ${k}`;

  inLat.value = (mo.lat ?? "");
  inLng.value = (mo.lng ?? "");
  inElev.value = (mo.elev ?? "");
  inNote.value = (mo.note ?? "");

  refreshCoordList();
}

coordFilterEl.addEventListener("input", () => refreshCoordList());
btnRefreshCoordList.onclick = () => refreshCoordList();

function tryGetSelectedMountain(){
  if (!selectedCoordKey) return null;
  return byName.get(selectedCoordKey) || null;
}

btnSave.onclick = async () => {
  if (!selectedCoordKey) return;

  const lat = Number(inLat.value);
  const lng = Number(inLng.value);
  const elev = (inElev.value === "" ? null : Number(inElev.value));
  const note = (inNote.value || "").trim();

  if (!Number.isFinite(lat) || !Number.isFinite(lng)){
    alert("ç·¯åº¦ãƒ»çµŒåº¦ã¯æ•°å€¤ã§å…¥åŠ›ã—ã¦ã­");
    return;
  }

  manualOverrides[selectedCoordKey] = { lat, lng, elev, note };
  saveManualOverrides(manualOverrides);

  const m = tryGetSelectedMountain();
  if (m){
    m.lat = lat; m.lng = lng;
    if (elev != null && Number.isFinite(elev)) m.elev = Math.round(elev);
    addMarkerForMountain(m);

    if (!m.weather || Object.keys(m.weather).length === 0){
      try{
        m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
      }catch{}
    }
  }

  pendingGeoSet.delete(selectedCoordKey);
  refreshCoordBadge();
  refreshCoordList();
  updateView();

  setStatusHtml([`âœ… æ‰‹å‹•åº§æ¨™ã‚’ä¿å­˜: ${selectedCoordKey}`]);
};

btnDelete.onclick = () => {
  if (!selectedCoordKey) return;
  if (!confirm(`æ‰‹å‹•åº§æ¨™ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n${selectedCoordKey}`)) return;

  delete manualOverrides[selectedCoordKey];
  saveManualOverrides(manualOverrides);

  inLat.value = ""; inLng.value = ""; inElev.value = ""; inNote.value = "";

  refreshCoordList();
  updateView();
  setStatusHtml([`ğŸ—‘ï¸ æ‰‹å‹•åº§æ¨™ã‚’å‰Šé™¤: ${selectedCoordKey}`]);
};

btnZoomTo.onclick = () => {
  if (!selectedCoordKey) return;
  const mo = manualOverrides?.[selectedCoordKey];
  const m = tryGetSelectedMountain();
  const lat = (mo?.lat != null) ? Number(mo.lat) : (m?.lat);
  const lng = (mo?.lng != null) ? Number(mo.lng) : (m?.lng);
  if (!Number.isFinite(lat) || !Number.isFinite(lng)){
    alert("ã¾ã åº§æ¨™ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆå…ˆã«ä¿å­˜ã—ã¦ãã ã•ã„ï¼‰");
    return;
  }
  closeCoordPanel();
  map.setView([lat, lng], 12);
};

btnExport.onclick = () => {
  taJson.value = JSON.stringify(manualOverrides || {}, null, 2);
  taJson.focus();
  taJson.select();
};

btnImport.onclick = () => {
  try{
    const obj = JSON.parse(taJson.value || "{}");
    if (!obj || typeof obj !== "object") throw new Error("invalid");
    manualOverrides = { ...(manualOverrides || {}), ...obj };
    saveManualOverrides(manualOverrides);
    refreshCoordList();
    updateView();
    setStatusHtml([`âœ… Importå®Œäº†ï¼ˆæ‰‹å‹•åº§æ¨™:${Object.keys(manualOverrides).length}ä»¶ï¼‰`]);
  }catch{
    alert("JSONã®å½¢å¼ãŒæ­£ã—ããªã„ã§ã™");
  }
};

btnClear.onclick = () => {
  if (!confirm("æ‰‹å‹•åº§æ¨™ã‚’å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) return;
  manualOverrides = {};
  saveManualOverrides(manualOverrides);
  refreshCoordList();
  updateView();
  setStatusHtml([`ğŸ—‘ï¸ æ‰‹å‹•åº§æ¨™ã‚’å…¨æ¶ˆå»ã—ã¾ã—ãŸ`]);
};

/* ===== init ===== */
async function init(){
  initDaySelectLabels();
  if (Number(daySelect.value) === 0) setSliderIndex(nearestTimeSlotIndexNow());

  // ç™¾åå±±ã¯å…ˆã«å¤©æ°—ç”Ÿæˆ
  const baseList = [...byName.values()].filter(m => m._sets?.has("HYAKU") && m.lat != null && m.lng != null);
  await Promise.all(baseList.map(async m => {
    if (!m.weather || Object.keys(m.weather).length === 0){
      m.weather = await generateWeatherScore(m.name, m.lat, m.lng, m.level, m.elev);
    }
  }));
  for (const m of baseList) addMarkerForMountain(m);

  // UIã‚¤ãƒ™ãƒ³ãƒˆ
  document.querySelectorAll("#control input,#control select").forEach(e => {
    if (e === daySelect) return;
    e.addEventListener("change", async () => {
      const { sets } = getState();
      for (const s of sets) await ensureSetLoaded(s);
      await resolveForEnabledSets();
      updateView();
      refreshCoordBadge();
    });
  });

  initMobileListGestures();
  setListCollapsed(isMobile() ? true : false);

  refreshCoordBadge();
  setStatusHtml([`åˆæœŸåŒ–å®Œäº†ï¼ˆç™¾åå±±:${baseList.length}åº§ï¼‰`]);
  updateView();
}
init();
</script>
</body>
</html>
