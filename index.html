<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>登山向け山岳マップ</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>

  <style>
    :root{
      --panel-bg:#f3f3f3;
      --card:#fff;
      --line:#ddd;
      --muted:#666;
      --chip:#eef2ff;
      --chip-text:#2b3a67;
    }
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; }
    #control {
      padding:10px;
      background:var(--panel-bg);
      font-size:14px;
      border-bottom:1px solid var(--line);
    }
    #container { display:flex; }
    #list {
      width: 320px;
      max-height: calc(100vh - 64px);
      overflow-y: auto;
      background: var(--card);
      border-right: 1px solid var(--line);
      padding: 8px;
      font-size: 13px;
    }
    #map { flex:1; height: calc(100vh - 64px); }

    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row + .row { margin-top:8px; }

    .seg { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .seg b { margin-right:6px; }

    /* ✅ チェックが左に寄る崩れを防ぐ（テキスト左、チェック右を固定） */
    .cb {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:4px 8px;
      background:#fff;
      border:1px solid var(--line);
      border-radius:8px;
      min-width: 92px;
      user-select:none;
    }
    .cb span { color:#111; }
    .cb input { margin:0; }

    .chip {
      display:inline-block;
      padding:4px 8px;
      border-radius:999px;
      background:var(--chip);
      color:var(--chip-text);
      border:1px solid #cbd5ff;
      font-size:12px;
      margin-left:8px;
    }
    #setStatus{
      margin-top:8px;
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
      max-width: 1200px;
    }

    .list-item{
      border-bottom: 1px solid var(--line);
      padding: 8px 6px;
      cursor: pointer;
    }
    .list-item:hover{ background:#f7fbff; }
    .nameLine{ display:flex; justify-content:space-between; gap:8px; }
    .nameLine b{ font-size:14px; }
    .metaLine{ margin-top:4px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap; }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      font-size:12px;
      color:#111;
    }
    .badge small{ color:var(--muted); font-size:11px; }

    .popup h3{ margin:0 0 6px 0; font-size:16px; }
    .popup .p{ margin:4px 0; font-size:13px; }
    .wxgrid{
      margin-top:6px;
      border-top:1px solid #eee;
      padding-top:6px;
      display:grid;
      grid-template-columns: 1fr;
      gap:6px;
      font-size:12px;
    }
    .wxrow{ display:flex; justify-content:space-between; gap:10px; }
    .wxrow .k{ color:var(--muted); }
    .scoreA{ color:#1b7f2a; font-weight:700; }
    .scoreB{ color:#a77700; font-weight:700; }
    .scoreC{ color:#b42318; font-weight:700; }

    /* スマホ */
    @media (max-width: 780px){
      #container{ flex-direction:column; }
      #list{ width:auto; max-height: 38vh; border-right:none; border-bottom:1px solid var(--line); }
      #map{ height: calc(100vh - 64px - 38vh); }
    }
  </style>
</head>

<body>
  <div id="control">
    <div class="row">
      <div class="seg">
        <b>日付</b>
        <select id="day">
          <option value="0">今日</option>
          <option value="1">1日後</option>
          <option value="2">2日後</option>
          <option value="3">3日後</option>
        </select>

        <b>時間帯</b>
        <input type="range" id="timeSlider" min="0" max="5" step="1" value="0">
        <span id="timeLabel">06–08</span>
      </div>

      <div class="seg">
        <b>天気</b>
        <label class="cb"><span>A</span><input type="checkbox" value="A" checked></label>
        <label class="cb"><span>B</span><input type="checkbox" value="B" checked></label>
        <label class="cb"><span>C</span><input type="checkbox" value="C" checked></label>

        <b>難易度</b>
        <label class="cb"><span>初級</span><input type="checkbox" value="初級" checked></label>
        <label class="cb"><span>中級</span><input type="checkbox" value="中級" checked></label>
        <label class="cb"><span>上級</span><input type="checkbox" value="上級" checked></label>
      </div>

      <div class="seg">
        <label class="cb" style="min-width:160px;">
          <span>登れる山だけ</span><input type="checkbox" id="goodOnly">
        </label>
      </div>

      <div class="seg">
        <b>表示セット</b>
        <label class="cb" style="min-width:170px;"><span>百名山</span><input type="checkbox" id="setHYAKU" checked></label>
        <label class="cb" style="min-width:170px;"><span>花の百名山</span><input type="checkbox" id="setHANA" checked></label>
        <label class="cb" style="min-width:170px;"><span>二百名山</span><input type="checkbox" id="setN200" checked></label>
        <span class="chip" id="countChip">読込中...</span>
      </div>
    </div>

    <div id="setStatus"></div>
  </div>

  <div id="container">
    <div id="list"></div>
    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script type="module">
    import mountains from "./mountains.js";
    import mountainsExtra from "./mountains_extra.js";
    import { generateWeatherScore } from "./weather.js";

    /* ========= time UI ========= */
    const timeSlots  = ["06:00","08:00","10:00","12:00","14:00","16:00"];
    const timeLabels = ["06–08","08–10","10–12","12–14","14–16","16–18"];
    const slider = document.getElementById("timeSlider");
    const timeLabel = document.getElementById("timeLabel");
    const daySelect = document.getElementById("day");

    function pad2(n){ return String(n).padStart(2,"0"); }
    const WDS = ["日","月","火","水","木","金","土"];
    function getDateObj(offset){
      const d = new Date(); d.setHours(0,0,0,0); d.setDate(d.getDate()+offset);
      return d;
    }
    function formatLocalYMD(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function getDateKey(offset){ return formatLocalYMD(getDateObj(offset)); }
    function dayLabel(offset){
      const d = getDateObj(offset);
      const mm = pad2(d.getMonth()+1), dd = pad2(d.getDate()), wd = WDS[d.getDay()];
      const rel = offset === 0 ? "今日" : `${offset}日後`;
      return `${mm}/${dd}(${wd}) ${rel}`;
    }
    function initDaySelectLabels(){
      [...daySelect.options].forEach(opt => opt.textContent = dayLabel(Number(opt.value)));
    }
    initDaySelectLabels();

    function nearestTimeSlotIndexNow(){
      const now = new Date();
      const nowMin = now.getHours()*60 + now.getMinutes();
      const starts = timeSlots.map(s => Number(s.slice(0,2))*60);
      let best = 0, bestDiff = Infinity;
      starts.forEach((m, i) => {
        const diff = Math.abs(nowMin - m);
        if (diff < bestDiff){ bestDiff = diff; best = i; }
      });
      if (nowMin < starts[0]) return 0;
      if (nowMin > starts[starts.length-1]) return starts.length-1;
      return best;
    }

    function getSelectedTimeSlot(){ return timeSlots[Number(slider.value)]; }
    function getDateOffset(){ return Number(daySelect.value); }

    slider.addEventListener("input", () => {
      timeLabel.textContent = timeLabels[Number(slider.value)];
      draw();
    });

    daySelect.addEventListener("change", () => {
      if (Number(daySelect.value) === 0){
        slider.value = String(nearestTimeSlotIndexNow());
        timeLabel.textContent = timeLabels[Number(slider.value)];
      }
      draw();
    });

    /* ========= filters ========= */
    const scoreChecks = () => [...document.querySelectorAll('input[type="checkbox"][value="A"],input[type="checkbox"][value="B"],input[type="checkbox"][value="C"]')]
      .filter(x=>x.checked).map(x=>x.value);

    const levelChecks = () => [...document.querySelectorAll('input[type="checkbox"][value="初級"],input[type="checkbox"][value="中級"],input[type="checkbox"][value="上級"]')]
      .filter(x=>x.checked).map(x=>x.value);

    const goodOnly = document.getElementById("goodOnly");

    const setHYAKU = document.getElementById("setHYAKU");
    const setHANA  = document.getElementById("setHANA");
    const setN200  = document.getElementById("setN200");

    const setStatus = document.getElementById("setStatus");
    const countChip = document.getElementById("countChip");

    function escapeHtml(s){
      return String(s ?? "").replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    function setStatusHtml(lines){
      const safe = (lines || []).filter(Boolean).slice(0, 14).map(escapeHtml);
      setStatus.innerHTML = safe.join("<br>");
    }

    function normName(s){
      return String(s||"")
        .replace(/\s+/g,"")
        .replace(/[‐-–—−]/g,"-")
        .trim();
    }

    /* ========= merge mountains =========
       - mountains.js(百名山) は常に HYAKU セット扱い
       - mountains_extra.js は _sets を尊重
       - 同名は統合して _sets を union
    */
    function withDefaultSets(m){
      const sets = Array.isArray(m._sets) ? m._sets.slice() : [];
      // 百名山側はHYAKUを付与
      if (!sets.includes("HYAKU") && m.__from === "BASE") sets.push("HYAKU");
      return { ...m, _sets: sets };
    }

    function mergeAll(base, extra){
      const map = new Map();

      base.forEach(m => {
        const key = normName(m.name);
        const mm = withDefaultSets({ ...m, __from:"BASE" });
        map.set(key, mm);
      });

      (extra || []).forEach(m => {
        const key = normName(m.name);
        if (!key) return;
        const ex = withDefaultSets({ ...m, __from:"EXTRA" });
        const cur = map.get(key);
        if (!cur){
          map.set(key, ex);
        }else{
          // 既存優先で座標/標高などは欠けを補完、_sets は union
          const sets = Array.from(new Set([...(cur._sets||[]), ...(ex._sets||[])]));
          map.set(key, {
            ...cur,
            lat:  (cur.lat  ?? ex.lat  ?? null),
            lng:  (cur.lng  ?? ex.lng  ?? null),
            elev: (cur.elev ?? ex.elev ?? null),
            level:(cur.level?? ex.level?? "中級"),
            gpx:  (cur.gpx  ?? ex.gpx  ?? null),
            _sets: sets
          });
        }
      });

      return [...map.values()];
    }

    const ALL = mergeAll(mountains, mountainsExtra);

    /* ========= map ========= */
    const mapObj = L.map("map").setView([36.5, 138.0], 5);

    // 地理院 標準地図 + 陰影（元の方針維持）
    L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",
      { attribution:"地理院タイル", opacity:0.85 }
    ).addTo(mapObj);

    L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/hillshademap/{z}/{x}/{y}.png",
      { attribution:"地理院 陰影", opacity:0.45 }
    ).addTo(mapObj);

    const markerLayer = L.layerGroup().addTo(mapObj);

    /* ========= marker icons =========
       ✅ “チープ”対策：Leafletカラー標準マーカーに戻す（見た目が安定）
    */
    function icon(color){
      return L.icon({
        iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
        shadowUrl: "https://unpkg.com/leaflet/dist/images/marker-shadow.png",
        iconSize:[25,41],
        iconAnchor:[12,41],
        popupAnchor:[1,-34],
        shadowSize:[41,41],
      });
    }
    const ICONS = {
      A: icon("green"),
      B: icon("yellow"),
      C: icon("red"),
      N: icon("grey"),
    };

    /* ========= weather cache in memory ========= */
    // mountainKey -> weatherObject
    const WX = new Map();
    const WX_META = { ok:0, ng:0, cacheHit:0, lastErr:"" };

    async function ensureWeatherFor(m){
      const key = normName(m.name);
      if (WX.has(key)) return WX.get(key);

      try{
        // generateWeatherScore の返り値は weather[dateKey][time] と weather.__detail が前提 :contentReference[oaicite:1]{index=1}
        const w = await generateWeatherScore(m.name, m.lat, m.lng, m.level || "中級", m.elev ?? null);
        WX.set(key, w);
        WX_META.ok++;
        return w;
      }catch(e){
        WX.set(key, null);
        WX_META.ng++;
        WX_META.lastErr = String(e?.message || e);
        return null;
      }
    }

    function scoreAt(m, dateKey, timeSlot){
      const w = WX.get(normName(m.name));
      if (!w) return null;
      return w?.[dateKey]?.[timeSlot] ?? null;
    }

    function detailAt(m, dateKey, timeSlot){
      const w = WX.get(normName(m.name));
      if (!w) return null;
      // ✅ “降水/風/突風/気温が表示されない”の主因：__detail を読む
      return w?.__detail?.[dateKey]?.[timeSlot] ?? null;
    }

    /* ========= set filter ========= */
    function selectedSets(){
      const s = [];
      if (setHYAKU.checked) s.push("HYAKU");
      if (setHANA.checked)  s.push("HANA_100");
      if (setN200.checked)  s.push("NIHON_200");
      return s;
    }
    function inSelectedSets(m){
      const want = selectedSets();
      const has = Array.isArray(m._sets) ? m._sets : [];
      return want.some(k => has.includes(k));
    }

    /* ========= list & popup ========= */
    function scoreClass(s){
      if (s==="A") return "scoreA";
      if (s==="B") return "scoreB";
      if (s==="C") return "scoreC";
      return "";
    }

    function popupHtml(m){
      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();
      const s = scoreAt(m, dateKey, timeSlot) || "—";
      const d = detailAt(m, dateKey, timeSlot);

      const sets = (m._sets||[]).map(x=>{
        if (x==="HYAKU") return "百";
        if (x==="HANA_100") return "花";
        if (x==="NIHON_200") return "200";
        return x;
      }).join(" / ");

      return `
        <div class="popup">
          <h3>${escapeHtml(m.name)}</h3>
          <div class="p">標高: ${m.elev ?? "?"}m　/　難易度: ${escapeHtml(m.level ?? "中級")}</div>
          <div class="p">セット: ${escapeHtml(sets || "-")}</div>
          <div class="p">天気スコア: <span class="${scoreClass(s)}">${escapeHtml(s)}</span>（${escapeHtml(dayLabel(getDateOffset()))} ${escapeHtml(timeSlot)}）</div>
          <div class="wxgrid">
            <div class="wxrow"><div class="k">降水</div><div>${d?.precip ?? "—"} mm</div></div>
            <div class="wxrow"><div class="k">風</div><div>${d?.wind ?? "—"} m/s</div></div>
            <div class="wxrow"><div class="k">突風</div><div>${d?.gust ?? "—"} m/s</div></div>
            <div class="wxrow"><div class="k">気温</div><div>${d?.temp ?? "—"} ℃</div></div>
          </div>
        </div>
      `;
    }

    /* ========= draw ========= */
    const listEl = document.getElementById("list");

    function computeCounts(){
      let hy=0, ha=0, n2=0;
      for (const m of ALL){
        const s = m._sets || [];
        if (s.includes("HYAKU")) hy++;
        if (s.includes("HANA_100")) ha++;
        if (s.includes("NIHON_200")) n2++;
      }
      return { hy, ha, n2, total: ALL.length };
    }

    function visibleMountains(){
      const scores = scoreChecks();
      const levels = levelChecks();
      const onlyGood = goodOnly.checked;

      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();

      return ALL
        .filter(m => m?.lat != null && m?.lng != null)
        .filter(m => inSelectedSets(m))
        .filter(m => levels.includes(m.level || "中級"))
        .filter(m => {
          const sc = scoreAt(m, dateKey, timeSlot);
          if (!sc) return true; // 未取得は一旦通す（自動取得で後から色が付く）
          if (!scores.includes(sc)) return false;
          if (onlyGood && sc !== "A") return false;
          return true;
        });
    }

    function sortKey(m){
      // A優先 / 次に標高高い順 / 名前
      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();
      const s = scoreAt(m, dateKey, timeSlot);
      const pri = (s==="A") ? 0 : (s==="B") ? 1 : (s==="C") ? 2 : 3;
      return { pri, elev: -(m.elev ?? 0), name: m.name };
    }

    const MARKERS = new Map(); // nameKey -> marker

    function refreshCountsUI(){
      const c = computeCounts();
      countChip.textContent = `登録: 百=${c.hy} / 花=${c.ha} / 200=${c.n2}`;
    }

    function refreshStatusUI(extraLines=[]){
      const lines = [
        `天気取得: OK=${WX_META.ok} / NG=${WX_META.ng}`,
        WX_META.lastErr ? `直近エラー: ${WX_META.lastErr}` : "",
        ...extraLines
      ].filter(Boolean);
      setStatusHtml(lines);
    }

    function draw(){
      refreshCountsUI();

      // marker update
      markerLayer.clearLayers();
      MARKERS.clear();

      const dateKey = getDateKey(getDateOffset());
      const timeSlot = getSelectedTimeSlot();

      const vis = visibleMountains()
        .sort((a,b)=>{
          const A = sortKey(a), B = sortKey(b);
          if (A.pri !== B.pri) return A.pri - B.pri;
          if (A.elev !== B.elev) return A.elev - B.elev;
          return String(A.name).localeCompare(String(B.name), "ja");
        });

      // list
      listEl.innerHTML = "";
      for (const m of vis){
        const sc = scoreAt(m, dateKey, timeSlot) || "—";
        const sets = (m._sets||[]).map(x=>{
          if (x==="HYAKU") return "百";
          if (x==="HANA_100") return "花";
          if (x==="NIHON_200") return "200";
          return x;
        }).join("/");

        const item = document.createElement("div");
        item.className = "list-item";
        item.innerHTML = `
          <div class="nameLine">
            <b>${escapeHtml(m.name)}</b>
            <span class="${scoreClass(sc)}">${escapeHtml(sc)}</span>
          </div>
          <div class="metaLine">
            <span class="badge"><small>標高</small>${escapeHtml(m.elev ?? "?")}m</span>
            <span class="badge"><small>難易度</small>${escapeHtml(m.level ?? "中級")}</span>
            <span class="badge"><small>セット</small>${escapeHtml(sets || "-")}</span>
          </div>
        `;
        item.addEventListener("click", () => {
          const mk = MARKERS.get(normName(m.name));
          if (mk){
            mapObj.setView([m.lat, m.lng], Math.max(mapObj.getZoom(), 9), { animate:true });
            mk.openPopup();
          }
        });
        listEl.appendChild(item);

        // marker
        const marker = L.marker([m.lat, m.lng], { icon: ICONS.N });
        marker.bindPopup(popupHtml(m), { maxWidth: 360 });
        marker.addTo(markerLayer);
        MARKERS.set(normName(m.name), marker);
      }

      refreshStatusUI([`表示: ${vis.length}件（${escapeHtml(dayLabel(getDateOffset()))} ${escapeHtml(timeSlot)}）`]);

      // ✅ “画面を動かさないと天気が来ない”対策：描画のたびに先読みを走らせる
      prefetchWeather(vis);
    }

    /* ========= auto prefetch (rate limited) ========= */
    let PREFETCH_RUNNING = false;

    async function prefetchWeather(list){
      if (PREFETCH_RUNNING) return;
      PREFETCH_RUNNING = true;

      try{
        // 一気に投げると 429 になるので、少数並列 + 待ち
        const concurrency = 3;
        const queue = list.slice(0, 60); // まずは見えてる上位から（体感優先）
        let idx = 0;

        async function worker(){
          while (idx < queue.length){
            const m = queue[idx++];
            await ensureWeatherFor(m);

            // marker色更新
            const dateKey = getDateKey(getDateOffset());
            const timeSlot = getSelectedTimeSlot();
            const sc = scoreAt(m, dateKey, timeSlot);
            const mk = MARKERS.get(normName(m.name));
            if (mk){
              mk.setIcon(ICONS[sc] || ICONS.N);
              mk.setPopupContent(popupHtml(m));
            }

            refreshStatusUI([`天気先読み中... ${Math.min(idx, queue.length)}/${queue.length}`]);
            await new Promise(r => setTimeout(r, 120)); // 軽く間引き
          }
        }

        await Promise.all(Array.from({length:concurrency}, worker));
        refreshStatusUI([`天気先読み完了（表示中 上位${Math.min(queue.length, list.length)}件）`]);

      }finally{
        PREFETCH_RUNNING = false;
      }
    }

    /* ========= events ========= */
    document.querySelectorAll('#control input[type="checkbox"]').forEach(el=>{
      el.addEventListener("change", draw);
    });

    // init
    slider.value = String(nearestTimeSlotIndexNow());
    timeLabel.textContent = timeLabels[Number(slider.value)];
    draw();
  </script>
</body>
</html>
